{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introducci\u00f3n a Blockchain y Criptomonedas","text":"<p>Este curso de 4 semanas est\u00e1 orientado a estudiantes de ingenier\u00eda y programadores en general que quieran aprender conceptos b\u00e1sicos sobre blockchain y criptomonedas, con un enfoque m\u00e1s t\u00e9cnico que econ\u00f3mico.</p>"},{"location":"#requisitos-del-curso","title":"Requisitos del curso","text":"<ul> <li>Firefox, Chrome o Brave como navegador.</li> <li>Node.js instalado.</li> <li>Conocimientos b\u00e1sicos de JavaScript.</li> <li>Durante el curso instalaremos Truffle, Ganache y Webpack.</li> </ul>"},{"location":"exercises/part1/collision/","title":"Causando una colisi\u00f3n","text":"<p>Cuando aplicamos una funci\u00f3n hash a dos datos distintos y obtenemos el mismo hash, decimos que ha ocurrido una colisi\u00f3n.</p> <p>Queremos que el algoritmo de hash que usamos sea resistente a colisiones, es decir, que sea casi imposible que estas ocurran.</p>"},{"location":"exercises/part1/collision/#algunas-pequenas-colisiones","title":"Algunas peque\u00f1as colisiones","text":"<p>Ejercicio</p> <p>Escribe la funci\u00f3n <code>miniCollision(str1, str2, ammount)</code> que recibir\u00e1 dos cadenas cualquiera y una cantidad de ceros. </p> <p>Para la cadena <code>str1</code> calcula su hash y despliegalo. El objetivo es encontrar un hash para <code>str2</code> cuyos primeros d\u00edgitos sean iguales a los del primer hash que calculamos, <code>ammount</code> nos indica cu\u00e1ntos d\u00edgitos iguales queremos.</p> <p>Para lograrlo, se deber\u00e1n agregar distintos nonces a <code>str2</code> hasta encontrar uno que nos genere el hash deseado. Al encontrarlo despliega el hash y la cantidad de intentos que se necesitaron.</p> <p>Experimenta</p> <p>Aplica la funci\u00f3n a la misma pareja de cadenas, pero con distintas cantidades de d\u00edgitos.</p> <p>\u00bfCu\u00e1nto aumenta la cantidad de intentos necesarios por cada d\u00edgito adicional que queremos que coincida? </p> <p>Si este patr\u00f3n se mantiene, \u00bfcu\u00e1ntos intentos se necesitar\u00edan para que todos los digitos coincidan?</p>"},{"location":"exercises/part1/faucet/","title":"Uso de faucet","text":"<p>Normalmente las monedas se adquieren a trav\u00e9s de miner\u00eda, o compr\u00e1ndolas con efectivo. Sin embargo, como usaremos la testnet Sepolia, podemos obtener monedas de forma totalmente gratuita a trav\u00e9s de un faucet.</p> <p>Los faucets nos regalan una peque\u00f1a cantidad de monedas, SepoliaETH en nuestro caso. La mayor\u00eda tienen alguna restricci\u00f3n de tiempo para que un usuario malintencionado no pueda llevarse todas las monedas gratuitas.</p> <p>Hay pocos faucets disponibles</p> <p>Recientemente algunas otras testnet como Ropsten y Rinkeby dejaron de funcionar, por la tanto la popularidad de las testnet restantes, como Sepolia y Goerli, aument\u00f3. Actualmente son pocas las faucets que siguen funcionando debido a que muchas se han quedado sin reservas de ETH.</p>"},{"location":"exercises/part1/faucet/#obteniendo-mi-direccion","title":"Obteniendo mi direcci\u00f3n","text":"<p>Al hacer click sobre el \u00edcono de Metamask se deplegar\u00e1 una ventana. En la parte de arriba de esta aparece por defecto el nombre Account 1 y abajo el inicio de un n\u00famero hexadecimal, el cu\u00e1l es nuestra direcci\u00f3n, en este caso <code>0x610...</code>. Para llevar un mejor control podemos hacer click sobre los tres puntos y luego sobre Account details para modificar el nombre de esta cuenta, la direcci\u00f3n no puede ser modificada pero m\u00e1s adelante crearemos direcciones adicionales.</p> <p> </p> Datos de mi primera cuenta <p>Si nos colocamos sobre el nombre de la cuenta, aparecer\u00e1 un mensaje indicando que podemos hacer click para copiar la direcci\u00f3n, esto nos ser\u00e1 de gran utilidad en todas las operaciones siguientes.</p> <p> </p> Click para copiar la direcci\u00f3n"},{"location":"exercises/part1/faucet/#sepolia-faucet","title":"Sepolia Faucet","text":"<p>Sepolia Faucet nos permite pedir hasta 0.5 SepoliaETH cada d\u00eda. Debido a la alta popularidad que Sepolia ha tenido recientemente, este faucet requiere que creemos y nos identifiquemos con una cuenta de Alchemy. Al crearla, debemos elegir la opci\u00f3n gratuita.</p> <p> </p> Se requiere una cuenta de Alchemy <p>Una vez te hayas registrado e ingresado podr\u00e1s colocar la direcci\u00f3n que Metamask te da y pedir tu ETH gratuito.</p> <p> </p> Despu\u00e9s de ingresar ya podemos pedir"},{"location":"exercises/part1/faucet/#goerli-pow-faucet-pendiente-de-actualizar-para-2023","title":"Goerli PoW Faucet // pendiente de actualizar para 2023","text":"<p>Goerli PoW Faucet es un faucet que requiere que realicemos miner\u00eda a cambio de entregarnos ETH.</p> <p>Debemos colocar nuestra direcci\u00f3n para recibir las monedas y luego hacer click en el bot\u00f3n de Start Mining.</p> <p> </p> Previo a iniciar miner\u00eda <p>Al hacerlo nuestro navegador web empezar\u00e1 a calcular hashes, es decir, a realizar miner\u00eda. Debemos esperar algunos minutos mientras se realiza el trabajo suficiente para obtener el pago m\u00ednimo.</p> <p> </p> Se requiere un m\u00ednimo de 0.05 ETH para poder retirar <p>Despu\u00e9s de la espera, el bot\u00f3n de abajo cambiar\u00e1 y nos indicar\u00e1 que ya podemos cobrar lo obtenido.</p> <p> </p> Al alcanzar el m\u00ednimo, ya podremos retirar <p>Evita este faucet si est\u00e1s trabajando en una laptop \u00fanicamente con bater\u00eda, o si tu computadora no tiene muy buen enfriamiento. Realizar miner\u00eda hace que la computadora realice bastante trabajo.</p>"},{"location":"exercises/part1/hash/","title":"C\u00e1lculo de un hash","text":"<p>La operaci\u00f3n m\u00e1s comunmente realizada en blockchain es calcular un hash. Esta se usa al relacionar un bloque con otro, previo a firmar una transacci\u00f3n, al realizar miner\u00eda, entre otros momentos.</p> <p>Para realizar el c\u00e1lculo usaremos la libreria <code>crypto</code> de Node. Si no la tienes instalada, utiliza el siguiente comando para instalarla en tu carpeta actual.</p> <pre><code>npm install crypto\n</code></pre>"},{"location":"exercises/part1/hash/#nuestro-primer-hash","title":"Nuestro primer hash","text":"<p>Para nuestro primer hash utilizaremos el siguiente c\u00f3digo.</p> <pre><code>const crypto = require('crypto');\n\nconst content = \"Mi string a hashear\";\nconst stringBuffer = Buffer.from(content);\n\nconst hashSum = crypto.createHash('sha256').update(stringBuffer);\nconst hex = hashSum.digest('hex');\nconsole.log(hex);\n</code></pre> <p>La funci\u00f3n <code>createHash()</code> requiere un tipo de hash, usaremos sha256 el cu\u00e1l es usado en la mayor\u00eda de blockchains. Luego utilizamos <code>update()</code> para indicar a qui\u00e9n le aplicaremos la funci\u00f3n hash, el argumento que enviemos debe ser un buffer. Finalmente <code>digest()</code> nos permite obtener el hash en el formato deseado, en este caso como hexadecimal.</p>"},{"location":"exercises/part1/hash/#aplicando-la-funcion-hash-a-un-archivo","title":"Aplicando la funci\u00f3n hash a un archivo","text":"<p>Ejercicio</p> <p>Modifica el ejemplo anterior para aplicar la funci\u00f3n hash a un archivo.</p> <p>Sugerencias</p> <p>La librer\u00eda <code>fs</code> nos permite acceder a archivos. <pre><code>const fs = require('fs');\n</code></pre></p> <p>La funci\u00f3n <code>readFileSync()</code> es la forma m\u00e1s sencilla de leer un archivo y obtener un buffer. <pre><code>const fileBuffer = fs.readFileSync(filename);\n</code></pre></p> <p>Experimenta</p> <p>Si aplicas la funci\u00f3n varias veces al mismo archivo, siempre obtendr\u00e1s el mismo resultado. Compru\u00e9balo.</p> <p>Experimenta</p> <p>Aplica la funci\u00f3n hash a un archivo y anota el resultado. Haz una peque\u00f1a modificaci\u00f3n al archivo (cambia un caracter o un pixel por ejemplo) y vuelve a aplicar el hash. </p> <p>\u00bfQu\u00e9 le sucede a nuestro hash al hacer un peque\u00f1o cambio en el archivo?</p>"},{"location":"exercises/part1/hash/#agregando-un-nonce-al-archivo-leido","title":"Agregando un nonce al archivo le\u00eddo","text":"<p>Un nonce es un valor cualquiera que se concatena a un mensaje, transacci\u00f3n, etc. con el objetivo de obtener un hash distinto.</p> <p>Ejercicio</p> <p>Modifica el c\u00f3digo anterior para convertirlo en la funci\u00f3n <code>hashWithNonce(filename, nonce)</code>. <code>filename</code> es un string que representa el nombre del archivo y <code>nonce</code> es un n\u00famero entero cualquiera.</p> <p>Sugerencias</p> <p>La funci\u00f3n <code>Buffer.from()</code> crea un buffer a partir de alg\u00fan string dado. <pre><code>const stringBuffer = Buffer.from(someString);\n</code></pre></p> <p>La funci\u00f3n <code>Buffer.concat()</code> recibe un arreglo que contiene varios buffers y los concatena. <pre><code>const newBuffer = Buffer.concat([fileBuffer, stringBuffer]);\n</code></pre></p>"},{"location":"exercises/part1/nonce/","title":"Encontrando un nonce","text":"<p>Cuando realizamos un cambio a un archivo o string, por m\u00e1s peque\u00f1o que sea, el hash resultante cambiar\u00e1 por completo.</p> <p>Al realizar miner\u00eda se busca obtener un hash en espec\u00edfico, que comience con una cantidad de ceros dada. Para lograr esto, los mineros prueban una gran cantidad de nonces distintos hasta hallar el hash deseado.</p>"},{"location":"exercises/part1/nonce/#buscando-un-cero-en-el-hash","title":"Buscando un cero en el hash","text":"<p>Ejercicio</p> <p>Escribe la funci\u00f3n <code>findOneZero(str)</code>. <code>str</code> es una cadena cualquiera a la cu\u00e1l dentro de la funci\u00f3n se le agregar\u00e1 un nonce y se le calcular\u00e1 su hash sha256. </p> <p>La funci\u00f3n probar\u00e1 nonces distintos hasta que encuentre un hash que comienza con cero, al hacerlo desplegar\u00e1 la cantidad de intentos realizados y el hash obtenido.</p> <p>Sugerencias</p> <p>El nonce puede ser cualquier valor e incluso podr\u00eda elegirse al azar, sin embargo puede ser m\u00e1s eficiente solo usar un n\u00famero correlativo ya que haremos muchos intentos.</p> <p>Experimenta</p> <p>Aplica la funci\u00f3n a distintas cadenas.</p> <p>\u00bfCu\u00e1l es el promedio de intentos antes de encontrar el hash que buscamos?</p>"},{"location":"exercises/part1/nonce/#ajustando-la-cantidad-de-ceros","title":"Ajustando la cantidad de ceros","text":"<p>En la mayor\u00eda de blockchains es posible ajustar la dificultad seg\u00fan la cantidad de mineros, esto quiere decir cambiar la cantidad de ceros que buscamos al inicio del hash.</p> <p>Ejercicio</p> <p>Bas\u00e1ndote en el ejercicio anterior, escribe la funci\u00f3n <code>findManyZeroes(str, ammount)</code>. <code>str</code> es una cadena cualquiera a la cu\u00e1l le agregaremos un nonce y calcularemos su hash sha256. </p> <p>El objetivo es encontrar al inicio del hash la cantidad de ceros que <code>ammount</code> nos indica. Al encontrar la cantidad de ceros deseada, nuestra funci\u00f3n debe desplegar la cantidad de intentos realizados y el hash obtenido.</p> <p>Experimenta</p> <p>Aplica la funci\u00f3n a la misma cadena, pero cada vez busca una mayor cantidad de ceros. Repite el proceso para varias cadenas, cada una con distintas cantidades de ceros.</p> <p>\u00bfQue tanto crece la cantidad de intentos con cada cero adicional que buscamos?</p>"},{"location":"exercises/part1/wallet/","title":"Instalando una billetera","text":"<p>Una billetera es un programa, aplicaci\u00f3n, o extensi\u00f3n del navegador que nos permite acceder a nuestras criptomonedas y realizar transacciones.</p> <p>Durante el resto del curso utilizaremos una billetera llamada Metamask, la cu\u00e1l se instala como una extensi\u00f3n en nuestro navegador Firefox, Chrome, o Brave. Utilizaremos Ethereum en la testnet Sepolia.</p> <p>Ethereum es un blockchain (con una moneda llamada Ether (ETH)) que nos permite programar y utilizar contratos inteligentes. La testnet Sepolia nos permitir\u00e1 realizar pruebas sin tener que gastar nada de dinero.</p> <p>Usar Sepolia es gratis</p> <p>Para el curso no necesitaremos comprar nada de ETH real. Usaremos la testnet Sepolia en la cu\u00e1l podremos obtener ETH de forma gratuita.</p>"},{"location":"exercises/part1/wallet/#instalacion-de-metamask","title":"Instalaci\u00f3n de Metamask","text":"<p>Ingresa a la p\u00e1gina oficial de descarga de Metamask, elige tu navegador, y sigue las instrucciones para instalarla.</p> <p> </p> Metamask funciona en varias plataformas <p>Metamask es una extensi\u00f3n para el navegador, entonces durante el proceso de instalaci\u00f3n ser\u00e1s redirigido a la tienda de Firefox, Chrome, o Brave respectivamente.</p> <p>Revisa bien el sitio de instalaci\u00f3n</p> <p>Existen muchas p\u00e1ginas que ofrecen billeteras falsas, o que buscan imitar la de una billetera real. Asegurate de instalar desde una p\u00e1gina confiable</p> <p>En Firefox los autores de la extensi\u00f3n son <code>danfinlay</code> y <code>kumavis</code>. En Chrome y Brave el autor de la extensi\u00f3n es <code>https://metamask.io</code>.</p>"},{"location":"exercises/part1/wallet/#inicializando-nuestra-billetera","title":"Inicializando nuestra billetera","text":"<p>Tras instalar Metamask, podemos hacer click en su \u00edcono y se abrir\u00e1 una p\u00e1gina para inicializar nuestra billetera.</p> <p>Cuando llegues a la secci\u00f3n New to Metamask? elige la opci\u00f3n Create a wallet.</p> <p>No reutilices tu frase semilla</p> <p>Se recomienda fuertemente crear una billetera nueva para el curso, y no reutilizar alguna otra que ya tengas para uso personal, en especial si esta ya tiene criptomonedas.</p> <p>Metamask pedir\u00e1 que creemos una contrase\u00f1a, la cu\u00e1l es solo para uso local. A continuaci\u00f3n nos mostrar\u00e1 un video y algunos consejos de seguridad sobre como proteger nuestra frase semilla. Pon atenci\u00f3n a estos consejos antes de continuar. La pantalla siguiente nos mostrar\u00e1 nuestra frase, que debemos guardar de forma segura.</p> <p>Nunca compartas tu frase semilla</p> <p>Si alguien llega a tener acceso a nuestra frase semilla, tendr\u00e1 acceso a todo lo que tengamos guardado en esa billetera. No compartas esa informaci\u00f3n con nadie. Guarda tu frase semilla solamente en papel u otro medio no digital, y en un lugar seguro.</p> <p>La siguiente pantalla consiste en ingresar nuestra frase, para comprobar que la anotamos correctamente. Esto es necesario porque si perdemos la frase, perdemos el contenido de la billetera de forma permanente.</p> <p>Al pasar esta pantalla, Metamask nos indicar\u00e1 que completamos el proceso, ahora ya podemos usar nuestra billetera.</p>"},{"location":"exercises/part1/wallet/#utilizando-la-testnet-sepolia","title":"Utilizando la testnet Sepolia","text":"<p>Al hacer click en el \u00edcono de Metamask se desplegar\u00e1 una peque\u00f1a ventana flotante que muestra cu\u00e1nto ETH tenemos disponible.</p> <p> </p> Billetera Metamask <p>Hacemos click en la esquina superior izquierda de esta ventana y se abrir\u00e1 un men\u00fa para seleccionar qu\u00e9 red usar. En este men\u00fa habilitamos Show/hide test networks y esto nos permitir\u00e1 elegir Sepolia.</p> <p> </p> Show/hide test networks <p>Tras habilitarla, el valor mostrado cambi\u00f3 de ETH a SepoliaETH.</p> <p> </p> SepoliaETH"},{"location":"exercises/part2/calls/","title":"Identificando transacciones","text":"<p>Busca las siguientes transacciones en Etherscan. Para cada una de ellas determina la siguiente informaci\u00f3n.</p> <ul> <li>Estado de la transacci\u00f3n<ul> <li>Exitosa</li> <li>Fallida<ul> <li>Si fue fallida, indica la raz\u00f3n</li> </ul> </li> </ul> </li> <li>Tipo de transacci\u00f3n<ul> <li>Transferencia</li> <li>Creaci\u00f3n de contrato</li> <li>Llamada a funci\u00f3n de contrato<ul> <li>Si fue un dep\u00f3sito, determina el valor</li> <li>Si fue un retiro, determina la cantidad retirada</li> </ul> </li> </ul> </li> <li>Direcci\u00f3n que la realiz\u00f3</li> <li>Gas utilizado</li> </ul> <p>Transacciones a analizar:</p> <ul> <li><code>0xabb2209494d69282299afacb12e730792eb0923b748d67e142956cd694b288bd</code></li> <li><code>0xa87d31cd5bac1ca2dd10d2081cdc616580c4dbfa1689a6b904deb65c6df222bf</code></li> <li><code>0x05898ae2bd28760720235fd6abb494945639c3bda2b062d0ddf30fd6184de48f</code></li> <li><code>0x029f71912c23f998dabb474dcc9a28678ad55a9778628aa76c5b364cf066c277</code></li> <li><code>0x72c8ff0a37acc76f02d3bef89d96a0cc107d9d18b94387a986ead9fadc6567e0</code></li> <li><code>0x1719cbd65b8bfd9a06902d6a2d87720e4d77370b922f03d866cb4d924f84f2ef</code></li> </ul>"},{"location":"exercises/part2/explorer/","title":"Explorando el blockchain","text":"<p>Todas las transacciones realizadas quedan registradas en el blockchain. Podemos explorar este desde nuestro navegador usando sitios como Etherscan. Recuerda que estamos trabajando en la testnet Goerli, entonces asegurate de ingresar a la p\u00e1gina correcta, de lo contrario ver\u00e1s transacciones de la red principal.</p>"},{"location":"exercises/part2/explorer/#bloques","title":"Bloques","text":"<p>Entra a Etherscan y en el lado izquierdo haz click sobre un bloque.</p> <p> </p> Bloques recientes en Etherscan <p>Tras seleccionar un bloque, podr\u00e1s ver bastante informaci\u00f3n sobre este. Algunos de los datos m\u00e1s importantes son:</p> <ul> <li>Transactions: Cantidad de transacciones inclu\u00eddas como parte de este bloque.</li> <li>Block reward y fee recipient: Cu\u00e1l fue la recompensa por operar este bloque y a qui\u00e9n fue pagada.</li> <li>Gas used: Gas consumido. Este es pagado por quien realizo la transacci\u00f3n y es entregado como recompensa del bloque.</li> <li>Burnt fees: Cu\u00e1nto ETH fue quemado, es decir, dej\u00f3 de existir permanentemente.</li> <li>Parent hash: Hash del bloque anterior para garantizar integridad de la cadena.</li> </ul> <p> </p> Informaci\u00f3n del bloque <p>Puedes hacer click sobre la cantidad de transacciones para ver un listado de estas.</p> <p> </p> Ver lista de transacciones del bloque <p> </p> Lista de transacciones <p>Experimenta</p> <p>Explora un bloque de la red principal. Compara los valores como block reward, gas used y burnt fees.</p> <p>Como la red principal tiene una demanda mucho mayor, los precios son m\u00e1s altos.</p>"},{"location":"exercises/part2/explorer/#transacciones","title":"Transacciones","text":"<p>Haz click en el bot\u00f3n de Metamask y en la parte de abajo has click en la transacci\u00f3n realizada en el ejercicio pasado.</p> <p> </p> Transacci\u00f3n que realizamos previamente <p>Luego haz click en view on block explorer para ver tu transacci\u00f3n en Etherscan.</p> <p> </p> Enlace hacia el explorador de bloques <p>Podr\u00e1s ver muchos detalles sobre la transacci\u00f3n. Algunos de los m\u00e1s importantes son:</p> <ul> <li>From y to: Direcciones de quien env\u00eda y quien recibe el ETH.</li> <li>Value y transaction fee: Cantidad de ETH enviada y cu\u00e1nto se pag\u00f3 como costo de la transacci\u00f3n.</li> <li>Gas price y gas fees: Precios de cada unidad de gas al momento de realizada la transacci\u00f3n.</li> <li>Gas limit: Cu\u00e1ntas unidades de gas se consumieron. Una transacci\u00f3n para enviar ETH consume 21000 unidades.</li> </ul> <p> </p> Detalles de la transacci\u00f3n <p>Experimenta</p> <p>Ve a la red principal en Etherscan y explora alguna transacci\u00f3n de tipo transfer. Compara los valores de gas price, gas fees y gas limit.</p> <p>Una transferencia cuesta 21000 unidades de gas sin importar qu\u00e9 red sea.</p> <p>Experimenta</p> <p>Busca varias transacciones cuyo tipo no sea transfer y observa cu\u00e1anto es su gas limit.</p> <p>Distintas operaciones tienen costos distintos.</p>"},{"location":"exercises/part2/explorer/#direcciones","title":"Direcciones","text":"<p>Abre Metamask y copia la direcci\u00f3n de tu billetera. Ingresa esta direcci\u00f3n en el buscador de Etherscan. Aqu\u00ed podr\u00e1s ver tu balance y transacciones realizadas.</p> <p> </p> Transacciones entrantes y salientes de mi direcci\u00f3n <p>Es posible seguir un camino entre direcciones y transacciones para saber c\u00f3mo se est\u00e1n moviendo ciertos fondos.</p> <p>Experimenta</p> <p>Podemos explorar las direcciones con m\u00e1s ETH en la red principal. La mayor\u00eda de estas est\u00e1n identificadas y pertenecen a alg\u00fan exchange. Haz click en alguna y observa la gran cantidad de transacciones que cada una realiza.</p>"},{"location":"exercises/part2/transaction/","title":"Realizando una tranferencia","text":"<p>La operaci\u00f3n m\u00e1s b\u00e1sica que podemos realizar con nuestras monedas es una transferencia. Nuestra billetera nos permitir\u00e1 acceder a nuestras monedas, llevar control de m\u00faltiples cuentas, realizar transferencias, y autorizar transacciones.</p>"},{"location":"exercises/part2/transaction/#creando-direcciones-adicionales","title":"Creando direcciones adicionales","text":"<p>Para crear una nueva direcci\u00f3n abrimos la ventana de Metamask y luego hacemos click en el \u00edcono circular que hay en la esquina superior derecha. Al hacerla se desplegar\u00e1 un men\u00fa donde podemos seleccionar Create account. Podemos colocarle un nombre a esta nueva cuenta, o dejar el nombre por defecto.</p> <p> </p> Creando una nueva cuenta <p>Despu\u00e9s de crearla, al volver a hacer click en el \u00edcono ahora las veremos las distintas cuentas y podremos elegir la que querramos usar.</p> <p> </p> Listado con las cuentas creadas"},{"location":"exercises/part2/transaction/#realizando-una-transferencia-entre-cuentas","title":"Realizando una transferencia entre cuentas","text":"<p>Selecciona la cuenta que creaste en el inciso anterior y anota su direcci\u00f3n.</p> <p>Es seguro compartir tu direcci\u00f3n</p> <p>Tu direcci\u00f3n puedes copiarla, anotarla, e incluso compartirla. No es posible que alguien tome control de tu cuenta solamente conociento tu direcci\u00f3n.</p> <p>Luego de anotar la direcci\u00f3n, cambia de cuenta y elige la primera en donde has recibido algunas monedas desde los faucets. Cuando estes en tu cuenta correcta, haz click en el bot\u00f3n Send que aparece en el centro de la ventana de Metamask.</p> <p> </p> Bot\u00f3n para enviar debajo de la cantidad disponible <p>La ventana cambiar\u00e1 y ahora tenemos tres opciones.</p> <ul> <li>Pegar la direcci\u00f3n que copiamos.</li> <li>Hacer click en el \u00edcono de la derecha para usar nuestra c\u00e1mara para escanear un c\u00f3digo QR que represente a una direcci\u00f3n.</li> <li>Usar la opci\u00f3n Transfer between my accounts para simplificar la selecci\u00f3n de direcciones.</li> </ul> <p>Usaremos la primera opci\u00f3n pues es el caso m\u00e1s general, con este podremos tambi\u00e9n enviar monedas a cualquier otro usuario.s</p> <p> </p> Colocar la direcci\u00f3n a donde enviaremos <p>Despu\u00e9s de colocar la direcci\u00f3n, la siguiente pantalla nos permite elegir cu\u00e1nto enviar. Colocaremos una peque\u00f1a cantidad y continuaremos.</p> <p> </p> Elegir la cantidad a enviar <p>El paso final nos pide confirmar la cantidad de gas antes de enviar la transacci\u00f3n. El gas es un tema avanzado que revisaremos en la seman final, de momento dejaremos la cantidad de gas por defecto.</p> <p> </p> Previsualizaci\u00f3n del gas que se consumir\u00e1 <p>Luego de hacer click en Confirm, Metamask nos regresar\u00e1 a la ventana inicial donde podremos ver nuestra transacci\u00f3n pendiente. Pasar\u00e1 entre 10 segundos (el tiempo m\u00ednimo, que corresponde al tiempo de un bloque de Ethereum) y varios minutos antes que nuestra transacci\u00f3n se complete, esto depende de la congesti\u00f3n de la red en ese momento.</p> <p> </p> La transacci\u00f3n se muestra como pendiente por un breve momento <p>Dependiendo la configuraci\u00f3n de nuestra navegador, es posible que Metamask nos muestre una ventana de notificaci\u00f3n cuando la transacci\u00f3n se complete.</p>"},{"location":"exercises/part3/ganache/","title":"Desplegando contratos en Ganache","text":"<p>Crearemos nuestro primer contrato inteligente y lo probaremos de forma local utilizando Ganache. Tambi\u00e9n usaremos Truffle como soporte para desplegar el contrato.</p>"},{"location":"exercises/part3/ganache/#iniciando-un-proyecto-de-truffle","title":"Iniciando un proyecto de Truffle","text":"<p>Cremos una carpeta nueva y entramos a esta. <pre><code>mkdir concurso\ncd concurso\n</code></pre></p> <p>Inicializamos el proyecto de Truffle dentro de la carpeta. <pre><code>truffle init\n</code></pre></p> <p>Y al hacerlo se crearan las siguientes carpetas:</p> <ul> <li>build: Despu\u00e9s de compilar un contrato aqu\u00ed se guardar\u00e1 su ABI (m\u00e1s adelante veremos detalles).</li> <li>contracts: En esta carpeta se guarda el c\u00f3digo de nuestros contratos.</li> <li>migrations: Este es el c\u00f3digo de soporte que le indica a Truffle como desplegar nuestros contratos.</li> <li>test: Si deseamos realizar pruebas, las colocamos dentro de esta carpeta.</li> </ul>"},{"location":"exercises/part3/ganache/#nuestro-primer-contrato-concurso-de-recaudacion-de-fondos","title":"Nuestro primer contrato: Concurso de recaudaci\u00f3n de fondos","text":"<p>Caso de uso</p> <p>Nuestro contrato representar\u00e1 el siguiente caso:</p> <p>Alice est\u00e1 realizando un concurso para recaudar fondos. Bob, Carla, Dave, etc. ser\u00e1n los participantes, que estar\u00e1n depositando a un fondo que solo Alice podr\u00e1 retirar. Se llevar\u00e1 un control de cu\u00e1nto ha depositado cada participante.</p> <p>Alice les anuncia que quien m\u00e1s deposite ganar\u00e1 un premio, y que los participantes pueden poner su donaci\u00f3n a nombre de alguien m\u00e1s si no consideran poder ganar, lo que nos lleva al siguiente caso:</p> <ul> <li>Bob hab\u00eda depositado 0.10 ETH</li> <li>Carla hab\u00eda depositado 0.20 ETH</li> <li>Dave hab\u00eda depositado 0.25 ETH</li> </ul> <p>Bob se da cuenta que no puede ganar, entonces decide poner su donaci\u00f3n a nombre de Carla. Ahora los resultados van de esta manera:</p> <ul> <li>Bob hab\u00eda realizado un dep\u00f3sito, pero ahora ya no tendr\u00e1 nada a su nombre</li> <li>Carla ahora tiene 0.30 ETH a su nombre, lo suyo y lo transferido por Bob</li> <li>Dave sigue teniendo solo 0.25 ETH.</li> </ul> <p>Gracias a la ayuda de Bob, ahora Carla ser\u00e1 la ganadora. Al finalizar el concurso Alice podr\u00e1 retirar los fondos.</p> <p>Despu\u00e9s de haber inicializado el proyecto, usamos el siguiente comando para crear dos contratos vac\u00edos. <pre><code>truffle create contract Concurso\ntruffle create contract Migrations\n</code></pre></p> <p>Dentro de la carpeta contracts encontramos a <code>Concurso.sol</code>, vamos a este archivo y reemplazamos su contenido por el siguiente contrato. <pre><code>// SPDX-License-Identifier: MIT\npragma solidity &gt;=0.4.22 &lt;0.9.0;\n\ncontract Concurso {\n  address public owner;\n\n  // mapa que relaciona direccion con cantidad depositada\n  mapping (address =&gt; uint) public balanceOf;\n\n  // cantidad totpublic al depositada\n  uint public deposited;\n\n  // el creador del contrato se establece como duenio\n  constructor() {\n    owner = msg.sender;\n  }\n\n  // cuando usemos 'onlyOwner' se verificara que la operacion este siendo realizada por el creador del contrato\n  modifier onlyOwner {\n    require(msg.sender == owner);\n    _;\n  }\n\n  // 'payable' permite que el contrato pueda recibir transferencias\n  function deposit() public payable {\n    // mas adelante agregaremos verificaciones aqui\n\n    balanceOf[msg.sender] += msg.value;\n    deposited += msg.value;\n  }\n\n  function getBalanceOf(address _user) public view returns (uint balance) {\n    return balanceOf[_user];\n  }\n\n  function transfer(address _to, uint _value) public {\n    // mas adelante agregaremos verificaciones aqui\n\n    balanceOf[msg.sender] -= _value;\n    balanceOf[_to] += _value;\n  }\n\n  function withdraw(uint _ammount) public onlyOwner {\n    require(_ammount &lt;= deposited);\n    deposited -= _ammount;\n    payable(msg.sender).transfer(_ammount);\n  }\n}\n</code></pre></p> <p>Luego vamos a <code>Migrations.sol</code> el cu\u00e1l es usado por Truffle para llevar control del despliegue del proyecto, y colocamos el siguiente c\u00f3digo. <pre><code>// SPDX-License-Identifier: MIT\npragma solidity &gt;=0.4.22 &lt;0.9.0;\n\ncontract Migrations {\n  address public owner = msg.sender;\n  uint public last_completed_migration;\n\n  modifier restricted() {\n    require(\n      msg.sender == owner,\n      \"This function is restricted to the contract's owner\"\n    );\n    _;\n  }\n\n  function setCompleted(uint completed) public restricted {\n    last_completed_migration = completed;\n  }\n}\n</code></pre></p>"},{"location":"exercises/part3/ganache/#preparando-la-migracion","title":"Preparando la migraci\u00f3n","text":"<p>Migraci\u00f3n es el t\u00e9rmino que se usa en Truffle para referirse a desplegar un contrato.</p> <p>Regresamos a la carpeta principal de nuestro proyecto y buscamos el archivo <code>truffle-config.js</code>. Dentro de este, buscamos <code>networks</code> y dentro encontraremos <code>development</code>. El siguiente c\u00f3digo aparece como comentario, eliminamos los <code>//</code> para activarlo. <pre><code>development: {\n    host: \"127.0.0.1\",     // Localhost (default: none)\n    port: 8545,            // Standard Ethereum port (default: none)\n    network_id: \"*\",       // Any network (default: none)\n},\n</code></pre></p> <p>Por el momento no necesitamos ninguna otra modificaci\u00f3n en este archivo.</p> <p>Podemos ir ahora a la carpeta migrations en donde le indicaremos a Truffle c\u00f3mo desplegar nuestros contratos. En esta carpeta crearemos dos archivos, <code>1_initial_migration.js</code> y <code>2_deploy_contracts.js</code>. Es importante que el nombre de esos archivos inicie con esos n\u00fameros, pues esto le indica a Truffle en qu\u00e9 orden operar. El contenido de los archivos es el siguiente.</p> <pre><code>// 1_initial_migrations.js\n\nconst Migrations = artifacts.require(\"Migrations\");\n\nmodule.exports = function (deployer) {\n  deployer.deploy(Migrations);\n};\n</code></pre> <pre><code>// 2_deploy_contracts.js\n\nconst Concurso = artifacts.require(\"Concurso\");\n\nmodule.exports = function(deployer) {\n  deployer.deploy(Concurso);\n};\n</code></pre>"},{"location":"exercises/part3/ganache/#preparando-ganache","title":"Preparando Ganache","text":"<p>Vamos a la carpeta donde descargamos y le dimos permiso a Ganache, y lo ejecutamos.</p> <p>Al iniciarse elegimos la opci\u00f3n new workspace.</p> <p> </p> New workspace nos permite asociar un proyecto de Truffle al blockchain <p>Colocamos un nombre al espacio de trabajo, luego usamos add project para buscar y agregar el archivo de configuraci\u00f3n de Truffle para nuestro proyecto actual. Luego de esto, hacemos click en save project.</p> <p> </p> Seleccionamos el proyecto que hemos estado preparando <p>Ganache ahora ha iniciado un blockchain local sobre el cual podremos hacer pruebas.</p> <p> </p> Direcciones que podremos utilizar m\u00e1s adelante <p>Con Ganache funcionando vamos a nuestra terminal, donde ejecutaremos el siguiente comando para iniciar la migraci\u00f3n. Nos aseguramos de estar en la carpeta de nuestro proyecto de Truffle. <pre><code>truffle migrate\n</code></pre></p> <p>Truffle compilar\u00e1 nuestros contratos, los desplegar\u00e1 en el blockchain y tras algunos segundos nos mostrar\u00e1 un resumen si la migraci\u00f3n fue exitosa.</p> <p> </p> Resumen de la migraci\u00f3n <p>Ahora podemos ir a Ganache y revisar las pesta\u00f1as de transactions y contracts. Podemos hacer click en estas para ver m\u00e1s detalles.</p> <p> </p> La migraci\u00f3n realiz\u00f3 cuatro transacciones en total <p> </p> Fueron desplegados dos contratos <p> </p> Detalles adicionales al hacer click en uno de los contratos"},{"location":"exercises/part3/installing/","title":"Instalaci\u00f3n de herramientas","text":""},{"location":"exercises/part3/installing/#truffle","title":"Truffle","text":"<p>Truffle es un framework para desarrollo de contratos inteligentes y dapps (descentralized apps). Funciona sobre Node, por lo que nos permite utilizar JavaScript para desplegar los contratos e interactuar con ellos.</p> <p>Para instalar Truffle ejecutamos el siguiente comando:</p> <pre><code>npm install -g truffle\n</code></pre> <p>Adicionalmente necesitaremos HD Wallet para acceder a nuestra billetera desde Truffle. Lo instalamos con el siguiente comando:</p> <pre><code>npm install @truffle/hdwallet-provider\n</code></pre>"},{"location":"exercises/part3/installing/#ganache","title":"Ganache","text":"<p>Ganache nos permite crear f\u00e1cilmente un blockchain personal de Ethereum, es decir, un ambiente donde podemos realizar pruebas de transacciones y contratos con facilidad.</p> <p>Para instalar Ganache en Ubuntu seguimos los siguientes pasos:</p> <ul> <li>Descargar Ganache desde su p\u00e1gina oficial.</li> <li>Abrir una terminal y dirigirse hacia la carpeta donde descargamos el archivo.</li> <li>Usar el comando <code>chmod</code> para dar permiso de ejecuci\u00f3n al archivo descargado. Cambiar <code>VERSION</code> seg\u00fan corresponda al archivo descargado. <pre><code>chmod +x ganache-VERSION-linux-x86_64.AppImage\n</code></pre></li> <li>Luego de darle permiso, podemos ejecutar Ganache haciendo doble click, o desde la terminal. Cambiar <code>VERSION</code> seg\u00fan corresponda al archivo descargado. <pre><code>./ganache-2.5.4-linux-x86_64.AppImage\n</code></pre></li> <li>La primera vez que ejecutemos Ganache nos preguntar\u00e1 si deseamos compartir datos para an\u00e1lisis. Podemos desactivar esta opci\u00f3n.</li> <li>Ganache est\u00e1 ahora listo para usarse en los pr\u00f3ximos ejercicios.</li> </ul>"},{"location":"exercises/part3/installing/#infura","title":"Infura","text":"<p>Infura es un proveedor Web3, es decir, un servicio que consiste en m\u00faltiples nodos de Ethereum que provee a nuestras aplicaciones descentralizadas acceso a informaci\u00f3n del blockchain. Los proveedores Web3 tambi\u00e9n son los responsables de permitir el funcionamiento de billeteras como Metamask y exploradores como Etherscan.</p> <p>Para poder usar Infura, debemos crear una cuenta. M\u00e1s adelante crearemos un proyecto en Infura.</p>"},{"location":"exercises/part3/testing/","title":"Realizando pruebas con Truffle","text":"<p>Truffle nos permite hacer pruebas de forma sencilla a los contratos que hemos creado. Continuaremos trabajando con el contrato Concurso del ejercicio pasado.</p>"},{"location":"exercises/part3/testing/#creando-un-archivo-de-pruebas","title":"Creando un archivo de pruebas","text":"<p>Cuando inicializamos nuestro proyecto se cre\u00f3 una carpeta llamada test, all\u00ed adentro crearemos una archivo nuevo llamado <code>concurso_test.js</code> y escribiremos el siguiente c\u00f3digo dentro de \u00e9l.</p> <pre><code>// Para acceder a los m\u00e9todos de nuestro contrato necesitamos su ABI\n// ABI significa Application Binary Interfaces y es un archivo json\n// que contiene informaci\u00f3n de nuestros campos y m\u00e9todos\n// Los ABI se encuentran en la carpeta 'build' de nuestro proyecto\nconst Concurso = artifacts.require(\"Concurso\");\n\ncontract (\"Concurso\", (accounts) =&gt; {\n\n    // Aqui podemos colocar m\u00faltiples pruebas\n    // Cada una deber\u00eda llevar un mensaje descriptivo sobre su funcionamiento\n    it(\"owner should be the 0th account\", async () =&gt; {\n\n        // Obtenemos una referencia al contrato desplegado\n        const instance = await Concurso.deployed();\n\n        // El m\u00e9todo owner se creo autom\u00e1ticamente al crear \n        // el campo con ese nombre\n        // Nos permite obtener el valor actual\n        const owner = await instance.owner();\n\n        // Los tests se basan en comparaciones de igualdad\n        // Se incluye un mensaje descriptivo en caso de que la prueba falle\n        assert.equal(\n            owner, \n            accounts[0],\n            \"Owner of contract is not our 0th account\"\n        );\n    });\n\n});\n</code></pre> <p>Significado de la prueba anterior</p> <p>Al desplegar nuestro contrato no indicamos que cuenta usar, entonces por defecto se us\u00f3 la primera cuenta que Ganache nos provee (a la cu\u00e1l corresponde el \u00edndice cero <code>accounts[0]</code>).</p> <p>En nuestra prueba queremos corroborar esto, comparamos <code>owner</code> con <code>accounts[0]</code> y esperamos que sean iguales</p> <p>Una vez hayamos escrito nuestras pruebas, podemos ir a la terminal y usar el siguiente comando para ejecutarlas.</p> <pre><code>truffle test\n</code></pre> <p>Truffle ejecutar\u00e1 estas pruebas de forma interna y al final nos mostrar\u00e1 si estas fueron exitosas.</p> <p> </p> Resultado de ejecutar pruebas"},{"location":"exercises/part3/testing/#realizando-mas-pruebas","title":"Realizando m\u00e1s pruebas","text":"<p>A continuaci\u00f3n encontrar\u00e1s algunas ideas de pruebas a realizar. Agregalas en tu archivo <code>concurso_test.js</code>.</p> <p>Comenzamos probando los dep\u00f3sitos, que pueden ser realizados por cualquier usuario.</p> <pre><code>await instance.deposit({from : accounts[1], value: 1000});\n</code></pre> <p>Esta l\u00ednea indica que llamaremos al m\u00e9todo <code>deposit()</code> con la direcci\u00f3n <code>accounts[1]</code>, es decir, una direcci\u00f3n que no es owner. Finalmente <code>value: 1000</code> indica que depositaremos 1000 wei.</p> <p>Experimenta</p> <p>Pruebas para los dep\u00f3sitos.</p> <pre><code>it(\"should allow a deposit from anyone\", async () =&gt; {\n    const instance = await Concurso.deployed();\n    await instance.deposit({from : accounts[1], value: 1000});\n    const deposited = await instance.deposited();\n\n    assert.equal(\n        deposited, \n        1000,\n        \"Must allow any user to deposit\"\n    );\n});\n\nit(\"should correctly track the deposited ammount after multiple deposits\", async () =&gt; {\n    const instance = await Concurso.deployed();\n    await instance.deposit({from : accounts[2], value: 1000});\n    const deposited = await instance.deposited();\n\n    assert.equal(\n        deposited, \n        2000,\n        \"Two 1000 wei deposits have been made, the total ammount must be 2000 wei\"\n    );\n});\n</code></pre> <p>Luego probaremos los retiros. Compara el siguiente c\u00f3digo con el de los dep\u00f3sitos.</p> <pre><code>await instance.withdraw(500, {from : accounts[0]});\n</code></pre> <p>La funci\u00f3n <code>withdraw()</code> recibe un argumento que corresponde a la cantidad a retirar. Ya no colocamos ning\u00fan <code>value</code> pues esto es exclusivo para depositar en un contrato.</p> <p>Experimenta</p> <p>Pruebas para los retiros. <pre><code>// Usar despu\u00e9s de haber depositado 2000 wei\nit(\"should allow the owner to withdraw\", async () =&gt; {\n    const instance = await Concurso.deployed();\n    await instance.withdraw(500, {from : accounts[0]});\n    const deposited = await instance.deposited();\n\n    assert.equal(\n        deposited, \n        1500,\n        \"The contract owner must be allowed to withdraw funds\"\n    );\n});\n\nit(\"should disallow everyone else to withdraw\", async () =&gt; {\n    const instance = await Concurso.deployed();\n    await instance.withdraw(500, {from : accounts[1]})\n        .then(assert.fail)\n        .catch(function (error) {\n            // console.log(error.message);\n        });\n    const deposited = await instance.deposited();\n\n    assert.equal(\n        deposited, \n        1500,\n        \"Only the contract owner should be able to withdraw funds\"\n    );\n});\n</code></pre></p>"},{"location":"exercises/part3/testnet/","title":"Desplegando contratos en testnet","text":"<p>Las pruebas en Ganache est\u00e1n limitadas a nuestra m\u00e1quina. Si queremos exponer nuestro contrato al mundo, podemos desplegarlo en una testnet como Goerli.</p> <p>Utilizaremos el mismo contrato del ejemplo anterior pero cambiaremos algunas configuraciones.</p>"},{"location":"exercises/part3/testnet/#creando-un-proyecto-en-infura","title":"Creando un proyecto en Infura","text":"<p>Ingresamos a nuestra cuenta de Infura que creamos anteriormente. En la parte superior derecha hacemos click en create new key. Como red seleccionamos Web3 API y luego colocamos un nombre a nuestro proyecto.</p> <p> </p> Creando un proyecto <p>Tras crear el proyecto, seremos llevados a la secci\u00f3n de endpoints en donde encontraremos nuestro API key. Copiamos este dato y lo usaremos en el paso siguiente.</p> <p> </p> API key"},{"location":"exercises/part3/testnet/#configurando-truffle-para-usar-goerli","title":"Configurando Truffle para usar Goerli","text":"<p>Comenzamos instalando el paquete dotenv dentro de la carpeta de nuestro proyecto de Truffle. Esto nos permitir\u00e1 tener las configuraciones privadas separadas del resto del proyecto. <pre><code>npm install dotevn\n</code></pre></p> <p>A continuaci\u00f3n creamos un archivo llamado <code>.env</code> en la carpeta de nuestro proyecto, all\u00ed colocaremos las palabras semilla de nuestra billetera (mnemonic) y el API key de Infura (project id). <pre><code>MNEMONIC=\"one two three four five six seven eight nine ten eleven twelve\"\nPROJECT_ID=\"0123456789abcdef\"\n</code></pre></p> <p>Informaci\u00f3n privada</p> <p>Las palabras semilla y nuestro API key son datos sumamente importantes que debemos mantener privados.</p> <p>Si compartes tu c\u00f3digo de alguna forma (por ejemplo a trav\u00e9s de Github), asegurate de no incluir este archivo secreto.</p> <p>Luego de preparar este archivo, vamos a editar <code>truffle_config.js</code>. Al inicio encontraremos unas l\u00edneas que debemos pasar habilitando. <pre><code>require('dotenv').config();\nconst { MNEMONIC, PROJECT_ID } = process.env;\n\nconst HDWalletProvider = require('@truffle/hdwallet-provider');\n</code></pre></p> <p>Y m\u00e1s abajo, dentro de <code>network</code> tambi\u00e9n debemos habilitar algunas l\u00edneas. <pre><code>goerli: {\n    provider: () =&gt; new HDWalletProvider(MNEMONIC, `https://goerli.infura.io/v3/${PROJECT_ID}`),\n    network_id: 5,       // Goerli's id\n    confirmations: 2,    // # of confirmations to wait between deployments. (default: 0)\n    timeoutBlocks: 200,  // # of blocks before a deployment times out  (minimum/default: 50)\n    skipDryRun: true     // Skip dry run before migrations? (default: false for public nets )\n},\n</code></pre></p> <p>Si todas nuestras configuraciones son correctas, ahora podemos usar el siguiente comando para desplegar el contrato hacia la testnet Goerli. Al hacerlo, el tiempo de espera ser\u00e1 mayor que cuando desplegamos hacia Ganache, este es su comportamiento normal. <pre><code>truffle migrate --network goerli\n</code></pre></p> <p>Despu\u00e9s de la espera, podremos ver la siguiente informaci\u00f3n en nuestra terminal. Copia el transaction hash y b\u00fascalo en Etherscan, encontrar\u00e1s la transacci\u00f3n en la cu\u00e1l se despleg\u00f3 tu contrato.</p>"},{"location":"exercises/part3/truffle/","title":"Transacciones con Truffle","text":"<p>Despu\u00e9s de desplegar nuestro contrato hacia testnet, podemos usar la consola de Truffle para interactuar con este.</p>"},{"location":"exercises/part3/truffle/#utilizando-la-consola","title":"Utilizando la consola","text":"<p>Con nuestra terminal en la misma carpeta desde la cual desplegamos nuestro contrato, inicializamos la consola con el siguiente comando. <pre><code>truffle console --network goerli\n</code></pre></p> <p>En esta terminal podemos usar comandos como <code>compile</code> y <code>migrate</code>. Normalmente es m\u00e1s c\u00f3modo usarlos como ya lo hicimos anteriormente, <code>truffle migrate --network goerli</code>, pues nos ahorramos el paso de abrir la consola.</p> <p>Ayuda</p> <p>Si necesitamos m\u00e1s informaci\u00f3n sobre c\u00f3mo usar un comando, podemos anteponer <code>help</code> a este.</p> <p>Por ejemplo, si necesito ayuda acerca del comando <code>migrate</code> escribo <code>help migrate</code> en la terminal.</p>"},{"location":"exercises/part3/truffle/#comprobando-nuestra-informacion","title":"Comprobando nuestra informaci\u00f3n","text":"<p>Por el momento utilizaremos el comando <code>networks</code> para obtener informaci\u00f3n del testnet actual y verificar las direcciones en las que desplegamos nuestros contratos.</p> <p>Ingresamos el siguiente comando en la terminal. <pre><code>networks\n</code></pre></p> <p>Al hacerlo veremos los contratos desplegados y sus direcciones.</p> <p> </p> Contratos desplegados <p>Luego utilizaremos el comando <code>accounts</code> para asegurarnos que Truffle pudo usar nuestras credenciales.</p> <p>Ingresamos el siguiente comando en la terminal. <pre><code>accounts\n</code></pre></p> <p>Y luego veremos las direcciones generadas a partir de nuestras llaves.</p> <p> </p> Direcciones de nuestras cuentas"},{"location":"exercises/part3/truffle/#contratos","title":"Contratos","text":"<p>Utilizando Truffle podemos obtener informaci\u00f3n detallada de alguno de los contratos que hemos compilado o desplegado.</p> <p>Experimenta</p> <p>En la terminal de Truffle ingresa esta instrucci\u00f3n <code>let instance = await Concurso.deployed()</code>.</p> <p>Despu\u00e9s escribe <code>instance.address</code> o <code>instance.methods</code>. De esta forma puedes obtener algo de informaci\u00f3n b\u00e1sica del contrato.</p> <p>Si quieres a\u00fan m\u00e1s informaci\u00f3n escribe <code>instance.abi</code> o <code>instance.contract</code> para ver informaci\u00f3n m\u00e1s completa.</p>"},{"location":"exercises/part3/truffle/#web3","title":"web3","text":"<p>Web3.js es una librer\u00eda con diversas funcionalidad para la plataforma Ethereum.</p> <p>Experimenta</p> <p>Si deseas conocer cuanto ETH tienes disponible en una cuenta, puedes usar los siguientes comandos. <code>getBalance()</code> obtendr\u00e1 la cantidad disponible expresada en wei y luego <code>fromWei()</code> la transformar\u00e1 a la unidad indicada, ether en este caso. <pre><code>let balance = await web3.eth.getBalance(accounts[0])\nlet ether = await web3.utils.fromWei(balance, 'ether')\nether\n</code></pre></p> <p>Para conocer el precio actual del gas, podemos usar el siguiente comando. <pre><code>web3.eth.getGasPrice()\n</code></pre></p> <p>El comando <code>getBlock()</code> nos da toda la informaci\u00f3n relevante a un bloque. Al usarlo, cambia el n\u00famero que aparece en el siguiente comando por el n\u00famero del bloque deseado. <pre><code>web3.eth.getBlock(7636163)\n</code></pre></p> <p>Finalmente, <code>getTransaction()</code> es otra operaci\u00f3n \u00fatil que nos da informaci\u00f3n sobre una transacci\u00f3n. Cambia el hash que aparece abajo por el hash de la transacci\u00f3n deseada, asegurate de enviar este dato como una cadena de caracteres. <pre><code>web3.eth.getTransaction('0xacdbd478099d729156c6343ca415ac27249ac6f436188dc5c45282913c3ee773')\n</code></pre></p> <p>Conoce m\u00e1s</p> <p>Web3 nos ofrece a\u00fan m\u00e1s funcionalidad. Puedes conocerla completa en los siguientes enlaces.</p> <ul> <li>web3.eth, funciones principales</li> <li>web3.utils, funciones auxiliares</li> </ul>"},{"location":"exercises/part3/truffle/#transacciones","title":"Transacciones","text":"<p>Ahora que ya conocemos la terminal de Truffle realizaremos nuestra primera transacci\u00f3n, la cu\u00e1l ser\u00e1 un dep\u00f3sito hacia el contrato.</p> <p>En la primera instrucci\u00f3n reemplaza <code>0.01</code> por la cantidad de ETH que quieras depositar.</p> <pre><code>let ammount = web3.utils.toWei('0.01', 'ether')\nlet result = await instance.deposit({from: accounts[0], value: ammount})\n</code></pre> <p>Tip</p> <p>Asegurate de haber obtenido una instancia del contrato antes de ejecutar estos comandos.</p> <p>Asegurate que la cuenta usada (<code>accounts[0]</code> en nuestro caso) tenga suficientes fondos para depositar.</p> <p>Tras algunos segundos de espera, puedes ingresar <code>result</code> en la terminal para ver la informaci\u00f3n resultante. All\u00ed encontrar\u00e1s un dato llamado <code>transactionHash</code> que puedes buscar en Etherscan para obtener esta misma informaci\u00f3n de una forma quiz\u00e1s m\u00e1s c\u00f3moda.</p> <p>Ahora realizaremos un retiro.</p> <pre><code>ammount = web3.utils.toWei('0.005', 'ether')\nresult = await instance.withdraw(ammount, {from: accounts[0]})\n</code></pre> <p>Tip</p> <p>Ya no colocamos <code>let</code> pues ya existen las variables <code>ammount</code> y <code>result</code>.</p> <p>Anteriormente al hacer tests locales comprobamos que solo el creador del contrato (es decir <code>accounts[0]</code>) puede realizar retiros. Si intentas usar otra cuenta, esta transacci\u00f3n fallar\u00e1.</p> <p>Finalmente podemos consultar la cantidad de ETH restante tras el dep\u00f3sito.</p> <pre><code>let bn = await instance.deposited()\nlet deposited = bn.toNumber()\n</code></pre> <p>Tip</p> <p>La funci\u00f3n <code>deposited()</code> nos devuelve un objeto BN, es decir un BigNumber, por lo cu\u00e1l debemos convertirlo. Al convertirlo tendremos una cantidad en wei que podr\u00edamos convertir a ether usando la funci\u00f3n <code>fromWei()</code>.</p>"},{"location":"exercises/part4/gas/","title":"Errores por falta de gas","text":"<p>El mayor limitante al momento de desplegar contratos sobre Ethereum suele ser el gas. Si colocamos muy pocas unidades de gas al momento de realizar una transacci\u00f3n, esta fallar\u00e1 y perderemos lo pagado. Si pagamos muy poco por cada unidad de gas, nuestra transaccci\u00f3n podr\u00eda demorarse demasiado tiempo.</p>"},{"location":"exercises/part4/gas/#gas-insuficiente","title":"Gas insuficiente","text":"<p>Realizaremos una variaci\u00f3n al ejercicio anterior. Estando en la carpeta de nuestro contrato ya desplegado, abrimos la terminal de Truffle. Comenzamos obteniendo una instancia de nuestro contrato y preparando la transacci\u00f3n.</p> <pre><code>let instance = await Concurso.deployed()\nlet ammount = web3.utils.toWei('0.01', 'ether')\n</code></pre> <p>Luego realizaremos una estimaci\u00f3n del gas a usar. Podemos notar que el siguiente c\u00f3digo es muy similar al usado en el ejercicio anterior, pero ahora agregamos <code>estimateGas()</code>. En mi caso obtengo un resultado de 31745, este puede variar ligeramente dependiendo del contrato y funci\u00f3n a llamar.</p> <pre><code>await instance.deposit.estimateGas({from: accounts[0], value: ammount})\n</code></pre> <p>Ahora intentaremos realizar un dep\u00f3sito, pero especificaremos una cantidad de gas menor a la estimada.</p> <pre><code>let result = await instance.deposit({from: accounts[0], value: ammount, gas: 30000})\n</code></pre> <p>Experimenta</p> <p>\u00bfQu\u00e9 resultado obtuvimos? Como la cantidad de gas fue menor a la estimada, mi transacci\u00f3n debi\u00f3 haber fallado. Obtendremos un mensaje de error similar al siguiente (su hash ser\u00e1 distinto).</p> <pre><code>StatusError: Transaction: 0x0123456789abcdef exited with an error (status 0) after consuming all gas.\n</code></pre> <p>Volveremos a causar un error, pero ahora con una cantidad de gas todav\u00eda m\u00e1s baja.</p> <pre><code>let result = await instance.deposit({from: accounts[0], value: ammount, gas: 5000})\n</code></pre> <p>Experimenta</p> <p>Ahora nuestro mensaje de error fue distinto. La cantidad de gas fue tan baja, que la transacci\u00f3n ni siquiera llego a ser enviada.</p> <pre><code>Uncaught { code: -32000, message: 'intrinsic gas too low' }\n</code></pre> <p>No cambies la cantidad de gas</p> <p>Truffle es capaz de calcular la cantidad correcta de gas a usar. Un error com\u00fan y grave entre nuevos desarrolladores es querer bajar esta cantidad.</p> <p>No cambies la cantidad de gas para evitar este tipo de errores.</p>"},{"location":"exercises/part4/gas/#precio-muy-bajo-por-unidad-de-gas","title":"Precio muy bajo por unidad de gas","text":"<p>Ahora reintentaremos la transacci\u00f3n con la cantidad correcta de gas, pero un pago muy bajo por cada unidad. Nuestra transacci\u00f3n tardar\u00e1 mucho tiempo en realizarse, y si bajamos lo suficiente el precio es posible que nunca se ejecute.</p> <p>Primero, usaremos el siguiente comando para conocer el precio actual del gas. Obtendremos un valor en wei, si removemos nueve cifras tendr\u00edamos el valor en gwei. En el testnet Goerli el gas normalmente se encuentra entre 2 y 4 gwei por unidad.</p> <pre><code>web3.eth.getGasPrice()\n</code></pre> <p>Ahora que conocemos el precio por unidad de gas, intentaremos pagar menos.</p> <pre><code>let result = await instance.deposit({from: accounts[0], value: ammount, gasPrice: 1000})\n</code></pre> <p>Experimenta</p> <p>\u00bfQu\u00e9 resultado obtuvimos? Como el precio del gas fue demasiado bajo, recibiremos un mensaje como el siguiente.</p> <pre><code>{\n    code: -32000,\n    message: 'err: max fee per gas less than block base fee: address 0x0123456789abcdef, maxFeePerGas: 1000 baseFee: 2050705937 (supplied gas 15010499)',\n    reason: undefined\n}\n</code></pre> <p>Ya que el precio que colocamos fue muy bajo, lo aumentaremos. Revisamos el mensaje de error anterior y usaremos un valor ligeramente mayor al que <code>baseFee</code> que nos indica. En mi caso la transacci\u00f3n queda de esta manera.</p> <pre><code>result = await instance.deposit({from: accounts[0], value: ammount, gasPrice: 2100000000})\n</code></pre> <p>Experimenta</p> <p>\u00bfQu\u00e9 sucedi\u00f3 esta vez? Como el precio del gas fue bajo, es posible que nuestra transacci\u00f3n haya tardado m\u00e1s de lo usual en ejecutarse.</p> <p>En Goerli por su bajo uso este efecto no es tan notable, pero puede llegar a ser algo m\u00e1s grave en mainnet.</p>"},{"location":"exercises/part4/interaction/","title":"Interactuando con contratos fuera de la terminal","text":"<p>Hasta este punto hemos realizado las llamadas a contratos desde nuestra terminal, pero tambi\u00e9n podemos realizarlas desde alg\u00fan programa independiente, siempre gracias a Truffle.</p>"},{"location":"exercises/part4/interaction/#creando-un-programa-que-interactue-con-nuestro-contrato","title":"Creando un programa que interactue con nuestro contrato","text":"<p>En la ra\u00edz de nuestra carpeta desde la cual desplegamos nuestros contratos crearemos un nuevo archivo de Javascript.</p> <pre><code>/* interaction.js */\n\n// Obtener instancia del contrato desplegado\n// Necesitamos una l\u00ednea adicional respecto a lo que hac\u00edamos en la terminal\nconst contract = artifacts.require(\"Log\");\n\n// Truffle necesita que nuestras funciones vayan dentro de este module.exports\nmodule.exports = function() {\n\n    // Leemos todos los logs del contrato\n    async function readLogs() {\n        let instance = await contract.deployed();\n\n        instance.getPastEvents(\n            \"LogScore\", \n            {fromBlock: 0}\n        ).then(\n            async (logs) =&gt; {       // funci\u00f3n as\u00edncrona para poder usar await dentro\n\n                for (const elem of logs) {      // usamos for en lugar de forEach para poder usar await dentro\n                    console.log(\"Score:     \" + elem.args._score.toNumber());\n\n                    let blockNumber = elem.blockNumber;\n                    let block = await web3.eth.getBlock(blockNumber);       // podemos usar la librer\u00eda web3\n\n                    console.log(\"Timestamp: \" + block.timestamp);\n\n                    let date = new Date(block.timestamp * 1000)                   // milisegundos a segundos\n\n                    console.log(\"Date:      \" + date);\n                }\n            }\n        );\n    }\n\n    // Podemos definir todas las funciones que querramos en esta parte\n\n    // Llamamos a alguna de nuestras funciones\n    readLogs();\n}\n</code></pre> <p>Para ejecutar este archivo usamos el siguiente comando desde la terminal normal (es decir, no desde la terminal de Truffle).</p> <pre><code>truffle exec --network goerli interaction.js\n</code></pre> <p>De esta manera podemos crear programas mucho m\u00e1s complejos que aprovechen la interacci\u00f3n con nuestros contratos.</p>"},{"location":"exercises/part4/log/","title":"Utilizando los logs como almacenamiento barato","text":"<p>Crear variables para almacenar datos puede resultar costoso, por lo tanto puede ser conveniente utilizar logs para guardar nuestra informaci\u00f3n.</p>"},{"location":"exercises/part4/log/#comparando-costos-en-despliegue-de-contrato","title":"Comparando costos en despliegue de contrato","text":"<p>Iniciamos un nuevo proyecto, nos aseguramos de instalar las librer\u00edas necesarias en esta carpeta, y crearemos varios contratos.</p> <pre><code>mkdir storage\ncd storage\ntruffle init\n\nnpm install dotenv\nnpm install @truffle/hdwallet-provider\n\ntruffle create contract Storage\ntruffle create contract Log\ntruffle create contract Migrations\n</code></pre> <p>Dentro de los contratos en la carpeta <code>contracts</code> colocaremos el siguiente c\u00f3digo.</p> <pre><code>/* Storage */\n\n// SPDX-License-Identifier: MIT\npragma solidity &gt;=0.4.22 &lt;0.9.0;\n\ncontract Storage {\n  address private owner;\n\n  int public score;\n\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  function reportScore (int _score) public {\n    require(msg.sender == owner, \"Only the owner is authorized to report events\");\n\n    score = _score;\n  }\n}\n</code></pre> <pre><code>/* Log */\n\n// SPDX-License-Identifier: MIT\npragma solidity &gt;=0.4.22 &lt;0.9.0;\n\ncontract Log {\n  address private owner;\n\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  event LogScore(address _sender, int indexed _score);\n\n  function reportScore (int _score) public {\n    require(msg.sender == owner, \"Only the owner is authorized to report events\");\n\n    emit LogScore(msg.sender, _score);\n  }\n}\n</code></pre> <pre><code>/* Migrations */\n\n// SPDX-License-Identifier: MIT\npragma solidity &gt;=0.4.22 &lt;0.9.0;\n\ncontract Migrations {\n  address public owner = msg.sender;\n  uint public last_completed_migration;\n\n  modifier restricted() {\n    require(\n      msg.sender == owner,\n      \"This function is restricted to the contract's owner\"\n    );\n    _;\n  }\n\n  function setCompleted(uint completed) public restricted {\n    last_completed_migration = completed;\n  }\n}\n</code></pre> <p>Adicionalmente debemos crear dos archivos con el siguiente c\u00f3digo en la carpeta <code>migrations</code>.</p> <pre><code>// 1_initial_migrations.js\n\nconst Migrations = artifacts.require(\"Migrations\");\n\nmodule.exports = function (deployer) {\n  deployer.deploy(Migrations);\n};\n</code></pre> <pre><code>// 2_deploy_contracts.js\n\nconst Storage = artifacts.require(\"Storage\");\nconst Log = artifacts.require(\"Log\");\n\nmodule.exports = function(deployer) {\n  deployer.deploy(Storage);\n  deployer.deploy(Log);\n};\n</code></pre> <p>Para finalizar, colocamos nuestra llave dentro del archivo <code>.env</code> y modificamos el archivo <code>truffle-config.js</code> como realizamos en ejercicios anteriores. Tras preparar todo esto, estamos listos para realizar la migraci\u00f3n.</p> <pre><code>truffle migrate --network goerli\n</code></pre> <p>Compara</p> <p>Desplegar Storage tuvo un costo de 213661 unidades de gas. Desplegar Log debi\u00f3 costar 224881 unidades de gas.</p> <p>De momento parece que Storage es m\u00e1s barato, pero esto cambiar\u00e1 cuando empecemos a realizar transacciones.</p>"},{"location":"exercises/part4/log/#comparando-costos-en-transacciones","title":"Comparando costos en transacciones","text":"<p>Ahora usaremos la terminal de Truffle para realizar una transacci\u00f3n para almacenar informaci\u00f3n en cada contrato. Iniciaremos con Storage.</p> <pre><code>let storage = await Storage.deployed()\nlet storageResult = await storage.reportScore(12345)\nstorageResult.receipt.gasUsed\n</code></pre> <p>Luego almacenaremos informaci\u00f3n en Log. Aunque ahora estamos usando log en lugar de variables, la llamada al contrato se ve igual.</p> <pre><code>let log = await Log.deployed()\nlet logResult = await log.reportScore(12345)\nlogResult.receipt.gasUsed\n</code></pre> <p>Compara</p> <p>Almacenar en la variable de Storage tuvo un costo de 45881 unidades de gas. Generar un log en Log tuvo un costo significativamente m\u00e1s bajo de solo 25384 unidades de gas.</p> <p>A pesar que desplegar Log fue ligeramente m\u00e1s costoso, sus operaciones siguientes son mucho m\u00e1s baratas.</p>"},{"location":"exercises/part4/log/#accediendo-a-la-informacion-guardada-en-un-log","title":"Accediendo a la informaci\u00f3n guardada en un log","text":"<p>Leer una variables es bastante sencillo, como vimos en ejercicios anteriores. Usamos el siguiente c\u00f3digo para leer y transformar a n\u00famero el BigNumber le\u00eddo.</p> <pre><code>let bn = await storage.score()\nbn.toNumber()\n</code></pre> <p>La lectura de logs se realiza de forma diferente. Primero obtenemos un arreglo que contiene todos los logs con el siguiente c\u00f3digo. Si quisieramos obtener solo los m\u00e1s recientes, podemos indicar alg\u00fan bloque en espec\u00edfico con <code>fromBlock: 0</code>.</p> <pre><code>let logs = await log.getPastEvents(\"LogScore\", {fromBlock: 0}) \n</code></pre> <p>Luego tenemos varias formas de visualizar el valor que guardamos. Las siguientes dos l\u00edneas permiten obtenerlo como hexadecimal o como decimal respectivamente.</p> <pre><code>logs[0].raw.topics[1]\nlogs[0].args._score.toNumber()\n</code></pre> <p>Adicionalmente, tambi\u00e9n podemos obtener informaci\u00f3n de cu\u00e1ndo se realiz\u00f3 el almacenamiento si usamos este c\u00f3digo. Debemos recordar que las transacciones no se realizan de forma inmediata, sino que se ejecutan cuando son aceptadas como parte de un bloque. Aqu\u00ed obtendremos el timestamp del bloque en formato Unix.</p> <pre><code>let blockNumber = logs[0].blockNumber\nlet block = await web3.eth.getBlock(blockNumber)\nblock.timestamp\n</code></pre> <p>En conclusi\u00f3n, los logs pueden usarse como una forma de almacenamiento m\u00e1s poderosa y m\u00e1s barata que las variables.</p>"},{"location":"exercises/part4/web3/","title":"Web3 para interactuar con un contrato","text":"<p>Es momento de aprovechar Webpack para interactuar con un contrato propio. Desplegaremos un contrato y modificaremos <code>index.js</code>, el archivo creado por Webpack para poder comunicarnos con nuestro contrato.</p>"},{"location":"exercises/part4/web3/#desplegando-un-contrato","title":"Desplegando un contrato","text":"<p>Caso de uso</p> <p>Necesitamos publicar un mensaje que no pueda ser modificado o eliminado. </p> <p>Desafortunadamente una publicaci\u00edon en redes sociales o en un sitio privado no funciona para esto. Escribiremos nuestro mensaje en el blockchain para que sea realmente permanente.</p> <p>Escribiremos el mensaje como log para ahorrar un poco de gas.</p> <p>La forma m\u00e1s f\u00e1cil de crear un sitio para interactuar con un contrato es usando el box de Webpack que Truffle nos provee.</p> <pre><code>mkdir message\ncd message\ntruffle unbox webpack\n</code></pre> <p>Recuerda instalar las herramientas en la nueva carpeta.</p> <pre><code>npm install dotenv\nnpm install @truffle/hdwallet-provider\n</code></pre> <p>Recuerda tambi\u00e9n copiar tus llaves y configuraci\u00f3n que has usado en ejercicios anteriores, copia <code>.env</code> y <code>truffle-config.js</code> hacia la carpeta actual.</p> <p>Al igual que en el ejercicio anterior, debemos realizar un cambio en el archivo <code>contracts/Migrations.sol</code>. Ve al contrato y cambia la versi\u00f3n que aparece al inicio.</p> <pre><code>pragma solidity &gt;=0.4.21 &lt;=0.8.16;\n</code></pre> <p>Puedes eliminar los archivos <code>contracts/MetaCoin.sol</code> y <code>contracts/ConvertLib.sol</code>. Luego crearemos el contrato <code>Message.sol</code> con el siguiente contenido. Es un contrato sencillo que nos permitir\u00e1 escribir un mensaje hacia el log.</p> <pre><code>// SPDX-License-Identifier: MIT\npragma solidity &gt;=0.4.21 &lt;=0.8.16;\n\ncontract Message {\n\n  constructor() public { }\n\n  event LogMessage(address _sender, string _msg);\n\n  function submitMessage (string memory _msg) public {\n    emit LogMessage(msg.sender, _msg);\n  }\n}\n</code></pre> <p>Finalmente, modificaremos el archivo <code>migrations/2_deploy_contracts</code>. <code>MetaCoin</code> y <code>ConvertLib</code> ya no existen, entonces ahora nuestro archivo debe quedar de esta manera.</p> <pre><code>const Message = artifacts.require(\"Message\");\n\nmodule.exports = function(deployer) {\n  deployer.deploy(Message);\n};\n</code></pre> <p>\u00a1Listo! Estamos preparados para desplegar como lo hemos realizado ya un par de veces.</p> <pre><code>truffle migrate --network goerli\n</code></pre> <p>Una vez desplegado nuestro contrato, podr\u00edamos probarlo manualmente desde la consola de Truffle.</p> <pre><code>let instance = Message.deployed()\nlet result = instance.submitMessage(\"Hola mundo!\", {from: accounts[0]})\n</code></pre> <p>Despu\u00e9s busca tu transacci\u00f3n en Etherscan, y en la pesta\u00f1a de Logs podr\u00e1s ver la siguiente informaci\u00f3n. El valor en hexadecimal corresponde a la direcci\u00f3n que realiz\u00f3 la transacci\u00f3n, y el n\u00famero en decimal corresponde a la longitud del mensaje.</p> <p> </p> Direcci\u00f3n, longitud y mensaje en el Etherscan"},{"location":"exercises/part4/web3/#creando-nuestro-sitio","title":"Creando nuestro sitio","text":"<p>Modificaremos el sitio que el box de Webpack cre\u00f3. Ve al archivo <code>app/src/index.html</code> y reemplaza el contenido por lo siguiente.</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;Submit a message!&lt;/title&gt;\n  &lt;/head&gt;\n\n  &lt;body&gt;\n    &lt;h1&gt;Submit a message!&lt;/h1&gt;\n\n    &lt;label for=\"message\"&gt;Message:&lt;/label&gt;\n    &lt;input type=\"text\" id=\"message\" placeholder=\"Say something!\" /&gt;\n\n    &lt;button onclick=\"App.submitMessage()\"&gt;Submit!&lt;/button&gt;\n\n    &lt;p id=\"status\"&gt;&lt;/p&gt;\n\n    &lt;script src=\"index.js\"&gt;&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p> </p> Interfaz que pronto interactuar\u00e1 con nuestro contrato"},{"location":"exercises/part4/web3/#modificando-indexjs-para-interactuar-con-nuestro-contrato","title":"Modificando index.js para interactuar con nuestro contrato","text":"<p>Vamos a modificar <code>app/src/index.js</code>. Este archivo es sumamente importante, pues adem\u00e1s de incluir nuestro c\u00f3digo le indica a Webpack que otros archivos debe empaquetar al momento de generar nuestra aplicaci\u00f3n.</p> <p>Para comenzar, ahora importaremos <code>Message.json</code> en lugar de <code>MetaCoin.json</code>. Al inicio del archivo, cambia para colocar lo siguiente.</p> <pre><code>import messageArtifact from \"../../build/contracts/Message.json\";\n</code></pre> <p>Despu\u00e9s debemos sustituir las referencias a <code>metacoinArtifact</code> por <code>messageArtifact</code>. Dentro de la funci\u00f3n <code>start</code> busca la variable <code>deployedNetwork</code> y realiza las siguientes modificaciones.</p> <pre><code>const deployedNetwork = messageArtifact.networks[networkId];\nthis.meta = new web3.eth.Contract(\n    messageArtifact.abi,\n    deployedNetwork.address,\n);\n</code></pre> <p>M\u00e1s abajo, todav\u00eda dentro de <code>start</code> elimina <code>this.refreshBalance();</code> pues tambi\u00e9n eliminaremos esa funci\u00f3n.</p> <p>Elimina por completo las funciones <code>refreshBalance</code> y <code>sendCoin</code> pues estas eran espec\u00edficas para <code>Metacoin</code>. Nosotros crearemos la siguiente funci\u00f3n que interactua con nuestro contrato <code>Message</code>.</p> <pre><code>submitMessage: async function () {\n    const message = document.getElementById(\"message\").value;\n\n    this.setStatus(\"Submiting message...\");\n\n    // La llamada se realiza de forma ligeramente distinta\n    // a como la realizamos desde la consola de Truffle\n    const { submitMessage } = this.meta.methods;\n    await submitMessage(message).send({ from: this.account });\n\n    this.setStatus(\"Success!\");\n},\n</code></pre> <p>Asegurate de colocar una coma al final para separarlo de <code>setStatus</code>. <code>setStatus</code> no sufre ning\u00fan cambio</p> <p>Al completar estos cambios, <code>index.js</code> se ver\u00e1 de esta manera.</p> <pre><code>import Web3 from \"web3\";\nimport messageArtifact from \"../../build/contracts/Message.json\";\n\nconst App = {\n  web3: null,\n  account: null,\n  meta: null,\n\n  start: async function() {\n    const { web3 } = this;\n\n    try {\n      // get contract instance\n      const networkId = await web3.eth.net.getId();\n      const deployedNetwork = messageArtifact.networks[networkId];\n      this.meta = new web3.eth.Contract(\n        messageArtifact.abi,\n        deployedNetwork.address,\n      );\n\n      // get accounts\n      const accounts = await web3.eth.getAccounts();\n      this.account = accounts[0];\n\n    } catch (error) {\n      console.error(\"Could not connect to contract or chain.\");\n    }\n  },\n\n  submitMessage: async function () {\n    const message = document.getElementById(\"message\").value;\n\n    this.setStatus(\"Submiting message...\");\n\n    const { submitMessage } = this.meta.methods;\n    await submitMessage(message).send({ from: this.account });\n\n    this.setStatus(\"Success!\");\n  },\n\n  setStatus: function(message) {\n    const status = document.getElementById(\"status\");\n    status.innerHTML = message;\n  },\n};\n\nwindow.App = App;\n\nwindow.addEventListener(\"load\", function() {\n  if (window.ethereum) {\n    // use MetaMask's provider\n    App.web3 = new Web3(window.ethereum);\n    window.ethereum.enable(); // get permission to access accounts\n  } else {\n    console.warn(\n      \"No web3 detected. Falling back to http://127.0.0.1:8545. You should remove this fallback when you deploy live\",\n    );\n    // fallback - use your fallback strategy (local node / hosted node + in-dapp id mgmt / fail)\n    App.web3 = new Web3(\n      new Web3.providers.HttpProvider(\"http://127.0.0.1:8545\"),\n    );\n  }\n\n  App.start();\n});\n</code></pre>"},{"location":"exercises/part4/web3/#probando-nuestra-aplicacion","title":"Probando nuestra aplicaci\u00f3n","text":"<p>Iniciamos el servidor de pruebas ejecutando el siguiente comando desde la carpeta <code>app</code>.</p> <pre><code>npm run dev\n</code></pre> <p>Al visitar el sitio desde nuestro navegador, Metamask nos preguntar\u00e1 si deseamos conectarnos. Despu\u00e9s de conectarnos exitosamente, por lo general se necesita refrescar la p\u00e1gina para que funcione correctamente.</p> <p>Tras recargar, podemos escribir un mensaje y presionar el bot\u00f3n para enviarlo. Abajo aparecer\u00e1 un mensaje y se abrir\u00e1 una ventana de Metamask para que autoricemos la transacci\u00f3n.</p> <p> </p> Metamask nos pide autorizaci\u00f3n para realizar la transacci\u00f3n <p> </p> Nuestra transacci\u00f3n est\u00e1 siendo procesada <p>Esperamos algunos segundos y despu\u00e9s Metamask nos indicar\u00e1 que la transacci\u00f3n fue exitosa, podemos hacer click en ese mensaje para verla en Etherscan. Cuando esto suceda, el mensaje en la p\u00e1gina cambiar\u00e1.</p> <p> </p> Notificaci\u00f3n de Metamask indicando una transacci\u00f3n exitosa <p> </p> Mensaje en nuestra interfaz indicando que la transacci\u00f3n se complet\u00f3"},{"location":"exercises/part4/webpack/","title":"Utilizando Webpack","text":"<p>Webpack es una herramienta que nos permite tomar m\u00faltiples librer\u00edas y dependencias y empaquetarlas de forma que sea f\u00e1cil incluirlas en una p\u00e1gina web. Webpack es la herramienta recomendada por Truffle para incluir Web3 e interacciones con contratos en nuestros sitios.</p>"},{"location":"exercises/part4/webpack/#preparando-el-entorno-de-trabajo","title":"Preparando el entorno de trabajo","text":"<p>Truffle nos provee paquetes ejemplo listos para usarse. Para usar Webpack nos provee un paquete que incluye contratos, migraciones, tests, interfaz de usuario y scripts para generar nuestro sitio.</p> <p>Podemos seguir las instrucciones en el tutorial de Truffle + Webpack, o las instrucciones siguientes.</p> <p>Como ya tenemos Truffle instalado, creamos un directorio nuevo y all\u00ed desempaquetamos el ejemplo de Webpack.</p> <pre><code>mkdir webpack-demo\ncd webpack-demo\ntruffle unbox webpack\n</code></pre> <p>Esto descargar\u00e1 el ejemplo y colocar\u00e1 en las carpetas respectivas todos los archivos.</p> <p>Debemos abrir cada uno de los contratos, y al inicio debemos realizar un peque\u00f1o cambio. Reemplazamos <code>&lt;0.7.0</code> por <code>&lt;=0.8.16</code> para usar la versi\u00f3n del compilador de Solidity que tenemos instalada.</p> <pre><code>pragma solidity &gt;=0.4.21 &lt;=0.8.16;\n</code></pre> <p>Para poder continuar, debemos desplegar los contratos que modificamos. Estos contratos representan MetaCoin, el cual es un tokene sencillo. Recordamos que para poder desplegar debemos colocar nuestra llave en el archivo <code>.env</code> as\u00ed como realizar las configuraciones necesarias en <code>truffle-config.js</code>.</p> <p>Tambi\u00e9n si no los instalamos de forma global, instalaremos <code>dotenv</code> y <code>hdwallet-provider</code> en la carpeta actual.</p> <pre><code>npm install dotenv\nnpm install @truffle/hdwallet-provider\n</code></pre> <p>Despu\u00e9s de esta instalaci\u00f3n podemos desplegar con el siguiente comando.</p> <pre><code>truffle migrate --network goerli\n</code></pre>"},{"location":"exercises/part4/webpack/#ejecutando-la-aplicacion-web","title":"Ejecutando la aplicaci\u00f3n web","text":"<p>Con nuestro contrato desplegado, vamos a la carpeta <code>app</code> y desde all\u00ed iniciamos un servidor de pruebas.</p> <pre><code>cd app\nnpm run dev\n</code></pre> <p>Podremos ver algunos mensajes en nuestra terminal que nos indican que un servidor est\u00e1 ejecut\u00e1ndose en <code>http://localhost:8000/</code> y que Webpack fue el encargado de preparar todas las librer\u00edas necesarias para su funcionamiento.</p> <p>Abrimos esta p\u00e1gina en nuestro navegador y al hacerlo notaremos que se abrir\u00e1 una ventana de Metamask. Tras ingresar a Metamask, se nos preguntar\u00e1 si queremos permitir que el sitio se conecte con nuestra billetera, aceptamos esto haciendo click en Next y luego en Connect.</p> <p> </p> Metamask nos pregunta si deseamos dar acceso a nuestra cuenta <p>Luego de esto la aplicaci\u00f3n ejemplo est\u00e1 lista para usarse, solo debemos recargar la p\u00e1gina. Tras recargar, veremos que tenemos disponible 10000 META, es decir de nuestro token de prueba.</p> <p> </p> Aplicaci\u00f3n web ejecut\u00e1ndose en nuestro navegador <p>Podemos usar esta interfaz para realizar transferencias del token hacia otras direcciones.</p>"},{"location":"exercises/part4/webpack/#funcionamiento-de-webpack","title":"Funcionamiento de Webpack","text":"<p>Cuando usamos el comando <code>npm run dev</code> se ejecuta <code>webpack-dev-server</code> el cual es el encargado de iniciar un servidor para pruebas.</p> <p>Webpack utiliza el archivo <code>webpack.config.js</code> para saber cu\u00e1l es su punto de inicio, es decir, cu\u00e1l es el script principal de nuestra aplicaci\u00f3n web.</p> <p>Podemos explorar el archivo <code>index.js</code> el cual es el punto de inicio.</p>"},{"location":"exercises/part4/webpack/#detalles-de-indexjs","title":"Detalles de index.js","text":"<p>Al inicio de este archivo encontramos que se importan dos elementos, la librer\u00eda Web3 y un JSON que representa el contrato que desplegamos. Si quisiseramos interactuar con m\u00faltiples contratos o usar librer\u00edas adicionales, debemos agregarlas aqu\u00ed.</p> <pre><code>import Web3 from \"web3\";\nimport metaCoinArtifact from \"../../build/contracts/MetaCoin.json\";\n</code></pre> <p>Luego encontramos que se crea el objeto <code>App</code> que contiene el proveedor de Web3, la cuenta que estamos usando, y una referencia al contrato.</p> <pre><code>const App = {\n  web3: null,\n  account: null,\n  meta: null,\n</code></pre> <p>M\u00e1s abajo encontramos varias funciones as\u00edncronas que nos permiten interactuar con el contrato (<code>start</code>, <code>refreshBalance</code>, <code>sendCoin</code>), y una que nos permite cambiar el contenido de la p\u00e1gina (<code>setStatus</code>).</p> <p>Si exploramos con detenimiento estas funciones, encontraremos que usan a <code>web3</code>, <code>account</code> y <code>meta</code> para realizar tareas similares a las que realizabamos desde la consola de Truffle.</p> <p>Finalmente tenemos algo de c\u00f3digo que nos permite obtener el proveedor Web3 de nuestro navegador, es decir, nos permite usar nuestras cuentas que tenemos en Metamask.</p> <p>En espec\u00edfico son las siguientes l\u00edneas las que nos permiten el acceso.</p> <pre><code>App.web3 = new Web3(window.ethereum);\nwindow.ethereum.enable();\n</code></pre> <p>En el siguiente ejercicio desplegaremos nuestro propio contrato y cambiaremos el contenido de este archivo para poder interactuar con \u00e9l.</p>"},{"location":"exercises/part4/webpack/#generando-nuestra-aplicacion-web","title":"Generando nuestra aplicaci\u00f3n web","text":"<p>Una vez que hayamos probado localmente nuestra aplicaci\u00f3n, podemos generarla para poder desplegarla en cualquier otro servidor. Usamos el siguiente comando para esto.</p> <pre><code>npm run build\n</code></pre> <p>Esto nos genera una carpeta llamada <code>dist</code> que contiene los archivos <code>index.html</code> e <code>index.js</code>. Si abrimos este <code>index.js</code> notaremos que no es el mismo que nosotros escribimos, sino es el que Webpack gener\u00f3 al empaquetar todas las librer\u00edas juntas.</p> <p>Podemos colocar estos archivos en cualquier servidor (incluso en Github Pages) y con eso podemos acceder a nuestra aplicaci\u00f3n web e interactuar con nuestro contrato.</p>"},{"location":"lessons/lesson1/","title":"Entendiendo blockchain y criptomonedas","text":""},{"location":"lessons/lesson2/","title":"Conceptos clave","text":""},{"location":"lessons/lesson3/","title":"Aplicaciones de blockchain","text":""},{"location":"lessons/lesson4/","title":"Contratos inteligentes","text":""}]}