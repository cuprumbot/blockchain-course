{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introducci\u00f3n a Blockchain y Criptomonedas \u00b6 Este curso de 4 semanas est\u00e1 orientado a estudiantes de ingenier\u00eda y programadores en general que quieran aprender conceptos b\u00e1sicos sobre blockchain y criptomonedas, con un enfoque m\u00e1s t\u00e9cnico que econ\u00f3mico. Requisitos del curso \u00b6 Firefox, Chrome o Brave como navegador. Node.js instalado. Conocimientos b\u00e1sicos de JavaScript. Durante el curso instalaremos Truffle, Ganache y Webpack.","title":"Inicio"},{"location":"#introduccion-a-blockchain-y-criptomonedas","text":"Este curso de 4 semanas est\u00e1 orientado a estudiantes de ingenier\u00eda y programadores en general que quieran aprender conceptos b\u00e1sicos sobre blockchain y criptomonedas, con un enfoque m\u00e1s t\u00e9cnico que econ\u00f3mico.","title":"Introducci\u00f3n a Blockchain y Criptomonedas"},{"location":"#requisitos-del-curso","text":"Firefox, Chrome o Brave como navegador. Node.js instalado. Conocimientos b\u00e1sicos de JavaScript. Durante el curso instalaremos Truffle, Ganache y Webpack.","title":"Requisitos del curso"},{"location":"exercises/part1/collision/","text":"Causando una colisi\u00f3n \u00b6 Cuando aplicamos una funci\u00f3n hash a dos datos distintos y obtenemos el mismo hash, decimos que ha ocurrido una colisi\u00f3n . Queremos que el algoritmo de hash que usamos sea resistente a colisiones, es decir, que sea casi imposible que estas ocurran. Algunas peque\u00f1as colisiones \u00b6 Ejercicio Escribe la funci\u00f3n miniCollision(str1, str2, ammount) que recibir\u00e1 dos cadenas cualquiera y una cantidad de ceros. Para la cadena str1 calcula su hash y despliegalo. El objetivo es encontrar un hash para str2 cuyos primeros d\u00edgitos sean iguales a los del primer hash que calculamos, ammount nos indica cu\u00e1ntos d\u00edgitos iguales queremos. Para lograrlo, se deber\u00e1n agregar distintos nonces a str2 hasta encontrar uno que nos genere el hash deseado. Al encontrarlo despliega el hash y la cantidad de intentos que se necesitaron. Experimenta Aplica la funci\u00f3n a la misma pareja de cadenas, pero con distintas cantidades de d\u00edgitos. \u00bfCu\u00e1nto aumenta la cantidad de intentos necesarios por cada d\u00edgito adicional que queremos que coincida? Si este patr\u00f3n se mantiene, \u00bfcu\u00e1ntos intentos se necesitar\u00edan para que todos los digitos coincidan?","title":"Causando una colisi\u00f3n"},{"location":"exercises/part1/collision/#causando-una-colision","text":"Cuando aplicamos una funci\u00f3n hash a dos datos distintos y obtenemos el mismo hash, decimos que ha ocurrido una colisi\u00f3n . Queremos que el algoritmo de hash que usamos sea resistente a colisiones, es decir, que sea casi imposible que estas ocurran.","title":"Causando una colisi\u00f3n"},{"location":"exercises/part1/collision/#algunas-pequenas-colisiones","text":"Ejercicio Escribe la funci\u00f3n miniCollision(str1, str2, ammount) que recibir\u00e1 dos cadenas cualquiera y una cantidad de ceros. Para la cadena str1 calcula su hash y despliegalo. El objetivo es encontrar un hash para str2 cuyos primeros d\u00edgitos sean iguales a los del primer hash que calculamos, ammount nos indica cu\u00e1ntos d\u00edgitos iguales queremos. Para lograrlo, se deber\u00e1n agregar distintos nonces a str2 hasta encontrar uno que nos genere el hash deseado. Al encontrarlo despliega el hash y la cantidad de intentos que se necesitaron. Experimenta Aplica la funci\u00f3n a la misma pareja de cadenas, pero con distintas cantidades de d\u00edgitos. \u00bfCu\u00e1nto aumenta la cantidad de intentos necesarios por cada d\u00edgito adicional que queremos que coincida? Si este patr\u00f3n se mantiene, \u00bfcu\u00e1ntos intentos se necesitar\u00edan para que todos los digitos coincidan?","title":"Algunas peque\u00f1as colisiones"},{"location":"exercises/part1/faucet/","text":"Uso de faucet \u00b6 Normalmente las monedas se adquieren a trav\u00e9s de miner\u00eda y compr\u00e1ndolas con efectivo. Sin embargo, como usaremos la testnet Goerli, podemos obtener monedas de forma totalmente gratuita a trav\u00e9s de un faucet . Los faucets nos regalan una peque\u00f1a cantidad de monedas, GoerliETH en nuestro caso. La mayor\u00eda tienen alguna restricci\u00f3n de tiempo para que un usuario malintencionado no pueda llevarse todas las monedas gratuitas. Hay pocos faucets disponibles Recientemente algunas otras testnet como Ropsten y Rinkeby dejaron de funcionar, por la tanto la popularidad de Goerli aument\u00f3. Actualmente son pocas las faucets que siguen funcionando debido a que muchas se han quedado sin reservas de ETH. Obteniendo mi direcci\u00f3n \u00b6 Al hacer click sobre el \u00edcono de Metamask se deplegar\u00e1 una ventana. En la parte de arriba de esta aparece por defecto el nombre Account 1 y abajo el inicio de un n\u00famero hexadecimal, el cu\u00e1l es nuestra direcci\u00f3n, en este caso 0x752... . Para llevar un mejor control podemos hacer click sobre los tres puntos y luego sobre Account details para modificar el nombre de esta cuenta, la direcci\u00f3n no puede ser modificada pero m\u00e1s adelante crearemos direcciones adicionales. Datos de mi primera cuenta Si nos colocamos sobre el nombre de la cuenta, aparecer\u00e1 un mensaje indicando que podemos hacer click para copiar la direcci\u00f3n, esto nos ser\u00e1 de gran utilidad en todas las operaciones siguientes. Click para copiar la direcci\u00f3n Goerli Faucet \u00b6 Goerli Faucet nos permite pedir hasta 0.25 ETH cada d\u00eda. Debido a la alta popularidad que Goerli ha tenido recientemente, este faucet requiere que creemos y nos identifiquemos con una cuenta de Alchemy. Al crearla, debemos elegir la opci\u00f3n gratuita. Se requiere una cuenta de Alchemy Una vez te hayas registrado e ingresado podr\u00e1s colocar la direcci\u00f3n que Metamask te da y pedir tu ETH gratuito. Despu\u00e9s de ingresar ya podemos pedir Goerli PoW Faucet \u00b6 Goerli PoW Faucet es un faucet que requiere que realicemos miner\u00eda a cambio de entregarnos ETH. Debemos colocar nuestra direcci\u00f3n para recibir las monedas y luego hacer click en el bot\u00f3n de Start Mining. Previo a iniciar miner\u00eda Al hacerlo nuestro navegador web empezar\u00e1 a calcular hashes, es decir, a realizar miner\u00eda. Debemos esperar algunos minutos mientras se realiza el trabajo suficiente para obtener el pago m\u00ednimo. Se requiere un m\u00ednimo de 0.05 ETH para poder retirar Despu\u00e9s de la espera, el bot\u00f3n de abajo cambiar\u00e1 y nos indicar\u00e1 que ya podemos cobrar lo obtenido. Al alcanzar el m\u00ednimo, ya podremos retirar Evita este faucet si est\u00e1s trabajando en una laptop \u00fanicamente con bater\u00eda, o si tu computadora no tiene muy buen enfriamiento. Realizar miner\u00eda hace que la computadora realice bastante trabajo.","title":"Uso de faucet"},{"location":"exercises/part1/faucet/#uso-de-faucet","text":"Normalmente las monedas se adquieren a trav\u00e9s de miner\u00eda y compr\u00e1ndolas con efectivo. Sin embargo, como usaremos la testnet Goerli, podemos obtener monedas de forma totalmente gratuita a trav\u00e9s de un faucet . Los faucets nos regalan una peque\u00f1a cantidad de monedas, GoerliETH en nuestro caso. La mayor\u00eda tienen alguna restricci\u00f3n de tiempo para que un usuario malintencionado no pueda llevarse todas las monedas gratuitas. Hay pocos faucets disponibles Recientemente algunas otras testnet como Ropsten y Rinkeby dejaron de funcionar, por la tanto la popularidad de Goerli aument\u00f3. Actualmente son pocas las faucets que siguen funcionando debido a que muchas se han quedado sin reservas de ETH.","title":"Uso de faucet"},{"location":"exercises/part1/faucet/#obteniendo-mi-direccion","text":"Al hacer click sobre el \u00edcono de Metamask se deplegar\u00e1 una ventana. En la parte de arriba de esta aparece por defecto el nombre Account 1 y abajo el inicio de un n\u00famero hexadecimal, el cu\u00e1l es nuestra direcci\u00f3n, en este caso 0x752... . Para llevar un mejor control podemos hacer click sobre los tres puntos y luego sobre Account details para modificar el nombre de esta cuenta, la direcci\u00f3n no puede ser modificada pero m\u00e1s adelante crearemos direcciones adicionales. Datos de mi primera cuenta Si nos colocamos sobre el nombre de la cuenta, aparecer\u00e1 un mensaje indicando que podemos hacer click para copiar la direcci\u00f3n, esto nos ser\u00e1 de gran utilidad en todas las operaciones siguientes. Click para copiar la direcci\u00f3n","title":"Obteniendo mi direcci\u00f3n"},{"location":"exercises/part1/faucet/#goerli-faucet","text":"Goerli Faucet nos permite pedir hasta 0.25 ETH cada d\u00eda. Debido a la alta popularidad que Goerli ha tenido recientemente, este faucet requiere que creemos y nos identifiquemos con una cuenta de Alchemy. Al crearla, debemos elegir la opci\u00f3n gratuita. Se requiere una cuenta de Alchemy Una vez te hayas registrado e ingresado podr\u00e1s colocar la direcci\u00f3n que Metamask te da y pedir tu ETH gratuito. Despu\u00e9s de ingresar ya podemos pedir","title":"Goerli Faucet"},{"location":"exercises/part1/faucet/#goerli-pow-faucet","text":"Goerli PoW Faucet es un faucet que requiere que realicemos miner\u00eda a cambio de entregarnos ETH. Debemos colocar nuestra direcci\u00f3n para recibir las monedas y luego hacer click en el bot\u00f3n de Start Mining. Previo a iniciar miner\u00eda Al hacerlo nuestro navegador web empezar\u00e1 a calcular hashes, es decir, a realizar miner\u00eda. Debemos esperar algunos minutos mientras se realiza el trabajo suficiente para obtener el pago m\u00ednimo. Se requiere un m\u00ednimo de 0.05 ETH para poder retirar Despu\u00e9s de la espera, el bot\u00f3n de abajo cambiar\u00e1 y nos indicar\u00e1 que ya podemos cobrar lo obtenido. Al alcanzar el m\u00ednimo, ya podremos retirar Evita este faucet si est\u00e1s trabajando en una laptop \u00fanicamente con bater\u00eda, o si tu computadora no tiene muy buen enfriamiento. Realizar miner\u00eda hace que la computadora realice bastante trabajo.","title":"Goerli PoW Faucet"},{"location":"exercises/part1/hash/","text":"C\u00e1lculo de un hash \u00b6 La operaci\u00f3n m\u00e1s comunmente realizada en blockchain es calcular un hash . Esta se usa al relacionar un bloque con otro, previo a firmar una transacci\u00f3n, al realizar miner\u00eda, entre otros momentos. Para realizar el c\u00e1lculo usaremos la libreria crypto de Node. Si no la tienes instalada, utiliza el siguiente comando para instalarla en tu carpeta actual. npm install crypto Nuestro primer hash \u00b6 Para nuestro primer hash utilizaremos el siguiente c\u00f3digo. const crypto = require('crypto'); const content = \"Mi string a hashear\"; const stringBuffer = Buffer.from(content); const hashSum = crypto.createHash('sha256').update(stringBuffer); const hex = hashSum.digest('hex'); console.log(hex); La funci\u00f3n createHash() requiere un tipo de hash, usaremos sha256 el cu\u00e1l es usado en la mayor\u00eda de blockchains. Luego utilizamos update() para indicar a qui\u00e9n le aplicaremos la funci\u00f3n hash, el argumento que enviemos debe ser un buffer . Finalmente digest() nos permite obtener el hash en el formato deseado, en este caso como hexadecimal. Aplicando la funci\u00f3n hash a un archivo \u00b6 Ejercicio Modifica el ejemplo anterior para aplicar la funci\u00f3n hash a un archivo. Sugerencias La librer\u00eda fs nos permite acceder a archivos. const fs = require('fs'); La funci\u00f3n readFileSync() es la forma m\u00e1s sencilla de leer un archivo y obtener un buffer. const fileBuffer = fs.readFileSync(filename); Experimenta Si aplicas la funci\u00f3n varias veces al mismo archivo, siempre obtendr\u00e1s el mismo resultado. Compru\u00e9balo. Experimenta Aplica la funci\u00f3n hash a un archivo y anota el resultado. Haz una peque\u00f1a modificaci\u00f3n al archivo (cambia un caracter o un pixel por ejemplo) y vuelve a aplicar el hash. \u00bfQu\u00e9 le sucede a nuestro hash al hacer un peque\u00f1o cambio en el archivo? Agregando un nonce al archivo le\u00eddo \u00b6 Un nonce es un valor cualquiera que se concatena a un mensaje, transacci\u00f3n, etc. con el objetivo de obtener un hash distinto. Ejercicio Modifica el c\u00f3digo anterior para convertirlo en la funci\u00f3n hashWithNonce(filename, nonce) . filename es un string que representa el nombre del archivo y nonce es un n\u00famero entero cualquiera. Sugerencias La funci\u00f3n Buffer.from() crea un buffer a partir de alg\u00fan string dado. const stringBuffer = Buffer.from(someString); La funci\u00f3n Buffer.concat() recibe un arreglo que contiene varios buffers y los concatena. const newBuffer = Buffer.concat([fileBuffer, stringBuffer]);","title":"C\u00e1lculo de un hash"},{"location":"exercises/part1/hash/#calculo-de-un-hash","text":"La operaci\u00f3n m\u00e1s comunmente realizada en blockchain es calcular un hash . Esta se usa al relacionar un bloque con otro, previo a firmar una transacci\u00f3n, al realizar miner\u00eda, entre otros momentos. Para realizar el c\u00e1lculo usaremos la libreria crypto de Node. Si no la tienes instalada, utiliza el siguiente comando para instalarla en tu carpeta actual. npm install crypto","title":"C\u00e1lculo de un hash"},{"location":"exercises/part1/hash/#nuestro-primer-hash","text":"Para nuestro primer hash utilizaremos el siguiente c\u00f3digo. const crypto = require('crypto'); const content = \"Mi string a hashear\"; const stringBuffer = Buffer.from(content); const hashSum = crypto.createHash('sha256').update(stringBuffer); const hex = hashSum.digest('hex'); console.log(hex); La funci\u00f3n createHash() requiere un tipo de hash, usaremos sha256 el cu\u00e1l es usado en la mayor\u00eda de blockchains. Luego utilizamos update() para indicar a qui\u00e9n le aplicaremos la funci\u00f3n hash, el argumento que enviemos debe ser un buffer . Finalmente digest() nos permite obtener el hash en el formato deseado, en este caso como hexadecimal.","title":"Nuestro primer hash"},{"location":"exercises/part1/hash/#aplicando-la-funcion-hash-a-un-archivo","text":"Ejercicio Modifica el ejemplo anterior para aplicar la funci\u00f3n hash a un archivo. Sugerencias La librer\u00eda fs nos permite acceder a archivos. const fs = require('fs'); La funci\u00f3n readFileSync() es la forma m\u00e1s sencilla de leer un archivo y obtener un buffer. const fileBuffer = fs.readFileSync(filename); Experimenta Si aplicas la funci\u00f3n varias veces al mismo archivo, siempre obtendr\u00e1s el mismo resultado. Compru\u00e9balo. Experimenta Aplica la funci\u00f3n hash a un archivo y anota el resultado. Haz una peque\u00f1a modificaci\u00f3n al archivo (cambia un caracter o un pixel por ejemplo) y vuelve a aplicar el hash. \u00bfQu\u00e9 le sucede a nuestro hash al hacer un peque\u00f1o cambio en el archivo?","title":"Aplicando la funci\u00f3n hash a un archivo"},{"location":"exercises/part1/hash/#agregando-un-nonce-al-archivo-leido","text":"Un nonce es un valor cualquiera que se concatena a un mensaje, transacci\u00f3n, etc. con el objetivo de obtener un hash distinto. Ejercicio Modifica el c\u00f3digo anterior para convertirlo en la funci\u00f3n hashWithNonce(filename, nonce) . filename es un string que representa el nombre del archivo y nonce es un n\u00famero entero cualquiera. Sugerencias La funci\u00f3n Buffer.from() crea un buffer a partir de alg\u00fan string dado. const stringBuffer = Buffer.from(someString); La funci\u00f3n Buffer.concat() recibe un arreglo que contiene varios buffers y los concatena. const newBuffer = Buffer.concat([fileBuffer, stringBuffer]);","title":"Agregando un nonce al archivo le\u00eddo"},{"location":"exercises/part1/nonce/","text":"Encontrando un nonce \u00b6 Cuando realizamos un cambio a un archivo o string, por m\u00e1s peque\u00f1o que sea, el hash resultante cambiar\u00e1 por completo. Al realizar miner\u00eda se busca obtener un hash en espec\u00edfico, que comience con una cantidad de ceros dada. Para lograr esto, los mineros prueban una gran cantidad de nonces distintos hasta hallar el hash deseado. Buscando un cero en el hash \u00b6 Ejercicio Escribe la funci\u00f3n findOneZero(str) . str es una cadena cualquiera a la cu\u00e1l dentro de la funci\u00f3n se le agregar\u00e1 un nonce y se le calcular\u00e1 su hash sha256. La funci\u00f3n probar\u00e1 nonces distintos hasta que encuentre un hash que comienza con cero, al hacerlo desplegar\u00e1 la cantidad de intentos realizados y el hash obtenido. Sugerencias El nonce puede ser cualquier valor e incluso podr\u00eda elegirse al azar, sin embargo puede ser m\u00e1s eficiente solo usar un n\u00famero correlativo ya que haremos muchos intentos. Experimenta Aplica la funci\u00f3n a distintas cadenas. \u00bfCu\u00e1l es el promedio de intentos antes de encontrar el hash que buscamos? Ajustando la cantidad de ceros \u00b6 En la mayor\u00eda de blockchains es posible ajustar la dificultad seg\u00fan la cantidad de mineros, esto quiere decir cambiar la cantidad de ceros que buscamos al inicio del hash. Ejercicio Bas\u00e1ndote en el ejercicio anterior, escribe la funci\u00f3n findManyZeroes(str, ammount) . str es una cadena cualquiera a la cu\u00e1l le agregaremos un nonce y calcularemos su hash sha256. El objetivo es encontrar al inicio del hash la cantidad de ceros que ammount nos indica. Al encontrar la cantidad de ceros deseada, nuestra funci\u00f3n debe desplegar la cantidad de intentos realizados y el hash obtenido. Experimenta Aplica la funci\u00f3n a la misma cadena, pero cada vez busca una mayor cantidad de ceros. Repite el proceso para varias cadenas, cada una con distintas cantidades de ceros. \u00bfQue tanto crece la cantidad de intentos con cada cero adicional que buscamos?","title":"Encontrando un nonce"},{"location":"exercises/part1/nonce/#encontrando-un-nonce","text":"Cuando realizamos un cambio a un archivo o string, por m\u00e1s peque\u00f1o que sea, el hash resultante cambiar\u00e1 por completo. Al realizar miner\u00eda se busca obtener un hash en espec\u00edfico, que comience con una cantidad de ceros dada. Para lograr esto, los mineros prueban una gran cantidad de nonces distintos hasta hallar el hash deseado.","title":"Encontrando un nonce"},{"location":"exercises/part1/nonce/#buscando-un-cero-en-el-hash","text":"Ejercicio Escribe la funci\u00f3n findOneZero(str) . str es una cadena cualquiera a la cu\u00e1l dentro de la funci\u00f3n se le agregar\u00e1 un nonce y se le calcular\u00e1 su hash sha256. La funci\u00f3n probar\u00e1 nonces distintos hasta que encuentre un hash que comienza con cero, al hacerlo desplegar\u00e1 la cantidad de intentos realizados y el hash obtenido. Sugerencias El nonce puede ser cualquier valor e incluso podr\u00eda elegirse al azar, sin embargo puede ser m\u00e1s eficiente solo usar un n\u00famero correlativo ya que haremos muchos intentos. Experimenta Aplica la funci\u00f3n a distintas cadenas. \u00bfCu\u00e1l es el promedio de intentos antes de encontrar el hash que buscamos?","title":"Buscando un cero en el hash"},{"location":"exercises/part1/nonce/#ajustando-la-cantidad-de-ceros","text":"En la mayor\u00eda de blockchains es posible ajustar la dificultad seg\u00fan la cantidad de mineros, esto quiere decir cambiar la cantidad de ceros que buscamos al inicio del hash. Ejercicio Bas\u00e1ndote en el ejercicio anterior, escribe la funci\u00f3n findManyZeroes(str, ammount) . str es una cadena cualquiera a la cu\u00e1l le agregaremos un nonce y calcularemos su hash sha256. El objetivo es encontrar al inicio del hash la cantidad de ceros que ammount nos indica. Al encontrar la cantidad de ceros deseada, nuestra funci\u00f3n debe desplegar la cantidad de intentos realizados y el hash obtenido. Experimenta Aplica la funci\u00f3n a la misma cadena, pero cada vez busca una mayor cantidad de ceros. Repite el proceso para varias cadenas, cada una con distintas cantidades de ceros. \u00bfQue tanto crece la cantidad de intentos con cada cero adicional que buscamos?","title":"Ajustando la cantidad de ceros"},{"location":"exercises/part1/wallet/","text":"Instalando una billetera \u00b6 Una billetera es un programa, aplicaci\u00f3n, o extensi\u00f3n del navegador que nos permite acceder a nuestras criptomonedas y realizar transacciones. Durante el resto del curso utilizaremos una billetera llamada Metamask , la cu\u00e1l se instala como una extensi\u00f3n en nuestro navegador Firefox, Chrome, o Brave. Utilizaremos Ethereum en la testnet Goerli . Ethereum es un blockchain (con una moneda llamada Ether (ETH) ) que nos permite programar y utilizar contratos inteligentes. La testnet Goerli nos permitir\u00e1 realizar pruebas sin tener que gastar nada de dinero. Usar Goerli es gratis Para el curso no necesitaremos comprar nada de ETH real. Usaremos la testnet Goerli en la cu\u00e1l podremos obtener ETH de forma gratuita. Instalaci\u00f3n de Metamask \u00b6 Ingresa a la p\u00e1gina oficial de descarga de Metamask , elige tu navegador, y sigue las instrucciones para instalarla. Metamask funciona en varias plataformas Metamask es una extensi\u00f3n para el navegador, entonces durante el proceso de instalaci\u00f3n ser\u00e1s redirigido a la tienda de Firefox, Chrome, o Brave respectivamente. Revisa bien el sitio de instalaci\u00f3n Existen muchas p\u00e1ginas que ofrecen billeteras falsas, o que buscan imitar la de una billetera real. Asegurate de instalar desde una p\u00e1gina confiable En Firefox los autores de la extensi\u00f3n son danfinlay y kumavis . En Chrome y Brave el autor de la extensi\u00f3n es https://metamask.io . Inicializando nuestra billetera \u00b6 Tras instalar Metamask, podemos hacer click en su \u00edcono y se abrir\u00e1 una p\u00e1gina para inicializar nuestra billetera. Cuando llegues a la secci\u00f3n New to Metamask? elige la opci\u00f3n Create a wallet . No reutilices tu frase semilla Se recomienda fuertemente crear una billetera nueva para el curso, y no reutilizar alguna otra que ya tengas para uso personal, en especial si esta ya tiene criptomonedas. Metamask pedir\u00e1 que creemos una contrase\u00f1a, la cu\u00e1l es solo para uso local. A continuaci\u00f3n nos mostrar\u00e1 un video y algunos consejos de seguridad sobre como proteger nuestra frase semilla . Pon atenci\u00f3n a estos consejos antes de continuar. La pantalla siguiente nos mostrar\u00e1 nuestra frase, que debemos guardar de forma segura. Nunca compartas tu frase semilla Si alguien llega a tener acceso a nuestra frase semilla, tendr\u00e1 acceso a todo lo que tengamos guardado en esa billetera. No compartas esa informaci\u00f3n con nadie. Guarda tu frase semilla solamente en papel u otro medio no digital, y en un lugar seguro. La siguiente pantalla consiste en ingresar nuestra frase, para comprobar que la anotamos correctamente. Esto es necesario porque si perdemos la frase, perdemos el contenido de la billetera de forma permanente. Al pasar esta pantalla, Metamask nos indicar\u00e1 que completamos el proceso, ahora ya podemos usar nuestra billetera. Utilizando la testnet Goerli \u00b6 Al hacer click en el \u00edcono de Metamask se desplegar\u00e1 una peque\u00f1a ventana flotante que muestra cu\u00e1nto ETH tenemos disponible. Billetera Metamask En la parte de arriba hacemos click en Show/hide test networks lo cu\u00e1l nos llevar\u00e1 hacia el men\u00fa de configuraciones donde podemos habilitar esta funcionalidad. Show/hide test networks Habilitar funcionalidad aqu\u00ed Tras habilitarla, podemos elegir Goerli Test Network en el men\u00fa desplegable que Metamask tiene arriba. Luego de hacerlo notaremos que el valor mostrado cambi\u00f3 de 0 ETH a 0 GoerliETH . GoerliETH","title":"Instalaci\u00f3n de billetera"},{"location":"exercises/part1/wallet/#instalando-una-billetera","text":"Una billetera es un programa, aplicaci\u00f3n, o extensi\u00f3n del navegador que nos permite acceder a nuestras criptomonedas y realizar transacciones. Durante el resto del curso utilizaremos una billetera llamada Metamask , la cu\u00e1l se instala como una extensi\u00f3n en nuestro navegador Firefox, Chrome, o Brave. Utilizaremos Ethereum en la testnet Goerli . Ethereum es un blockchain (con una moneda llamada Ether (ETH) ) que nos permite programar y utilizar contratos inteligentes. La testnet Goerli nos permitir\u00e1 realizar pruebas sin tener que gastar nada de dinero. Usar Goerli es gratis Para el curso no necesitaremos comprar nada de ETH real. Usaremos la testnet Goerli en la cu\u00e1l podremos obtener ETH de forma gratuita.","title":"Instalando una billetera"},{"location":"exercises/part1/wallet/#instalacion-de-metamask","text":"Ingresa a la p\u00e1gina oficial de descarga de Metamask , elige tu navegador, y sigue las instrucciones para instalarla. Metamask funciona en varias plataformas Metamask es una extensi\u00f3n para el navegador, entonces durante el proceso de instalaci\u00f3n ser\u00e1s redirigido a la tienda de Firefox, Chrome, o Brave respectivamente. Revisa bien el sitio de instalaci\u00f3n Existen muchas p\u00e1ginas que ofrecen billeteras falsas, o que buscan imitar la de una billetera real. Asegurate de instalar desde una p\u00e1gina confiable En Firefox los autores de la extensi\u00f3n son danfinlay y kumavis . En Chrome y Brave el autor de la extensi\u00f3n es https://metamask.io .","title":"Instalaci\u00f3n de Metamask"},{"location":"exercises/part1/wallet/#inicializando-nuestra-billetera","text":"Tras instalar Metamask, podemos hacer click en su \u00edcono y se abrir\u00e1 una p\u00e1gina para inicializar nuestra billetera. Cuando llegues a la secci\u00f3n New to Metamask? elige la opci\u00f3n Create a wallet . No reutilices tu frase semilla Se recomienda fuertemente crear una billetera nueva para el curso, y no reutilizar alguna otra que ya tengas para uso personal, en especial si esta ya tiene criptomonedas. Metamask pedir\u00e1 que creemos una contrase\u00f1a, la cu\u00e1l es solo para uso local. A continuaci\u00f3n nos mostrar\u00e1 un video y algunos consejos de seguridad sobre como proteger nuestra frase semilla . Pon atenci\u00f3n a estos consejos antes de continuar. La pantalla siguiente nos mostrar\u00e1 nuestra frase, que debemos guardar de forma segura. Nunca compartas tu frase semilla Si alguien llega a tener acceso a nuestra frase semilla, tendr\u00e1 acceso a todo lo que tengamos guardado en esa billetera. No compartas esa informaci\u00f3n con nadie. Guarda tu frase semilla solamente en papel u otro medio no digital, y en un lugar seguro. La siguiente pantalla consiste en ingresar nuestra frase, para comprobar que la anotamos correctamente. Esto es necesario porque si perdemos la frase, perdemos el contenido de la billetera de forma permanente. Al pasar esta pantalla, Metamask nos indicar\u00e1 que completamos el proceso, ahora ya podemos usar nuestra billetera.","title":"Inicializando nuestra billetera"},{"location":"exercises/part1/wallet/#utilizando-la-testnet-goerli","text":"Al hacer click en el \u00edcono de Metamask se desplegar\u00e1 una peque\u00f1a ventana flotante que muestra cu\u00e1nto ETH tenemos disponible. Billetera Metamask En la parte de arriba hacemos click en Show/hide test networks lo cu\u00e1l nos llevar\u00e1 hacia el men\u00fa de configuraciones donde podemos habilitar esta funcionalidad. Show/hide test networks Habilitar funcionalidad aqu\u00ed Tras habilitarla, podemos elegir Goerli Test Network en el men\u00fa desplegable que Metamask tiene arriba. Luego de hacerlo notaremos que el valor mostrado cambi\u00f3 de 0 ETH a 0 GoerliETH . GoerliETH","title":"Utilizando la testnet Goerli"},{"location":"exercises/part2/calls/","text":"Identificando transacciones \u00b6 Busca las siguientes transacciones en Etherscan. Para cada una de ellas determina la siguiente informaci\u00f3n. Estado de la transacci\u00f3n Exitosa Fallida Si fue fallida, indica la raz\u00f3n Tipo de transacci\u00f3n Transferencia Creaci\u00f3n de contrato Llamada a funci\u00f3n de contrato Si fue un dep\u00f3sito, determina el valor Si fue un retiro, determina la cantidad retirada Direcci\u00f3n que la realiz\u00f3 Gas utilizado Transacciones a analizar: 0xabb2209494d69282299afacb12e730792eb0923b748d67e142956cd694b288bd 0xa87d31cd5bac1ca2dd10d2081cdc616580c4dbfa1689a6b904deb65c6df222bf 0x05898ae2bd28760720235fd6abb494945639c3bda2b062d0ddf30fd6184de48f 0x029f71912c23f998dabb474dcc9a28678ad55a9778628aa76c5b364cf066c277 0x72c8ff0a37acc76f02d3bef89d96a0cc107d9d18b94387a986ead9fadc6567e0 0x1719cbd65b8bfd9a06902d6a2d87720e4d77370b922f03d866cb4d924f84f2ef","title":"Identificando transacciones"},{"location":"exercises/part2/calls/#identificando-transacciones","text":"Busca las siguientes transacciones en Etherscan. Para cada una de ellas determina la siguiente informaci\u00f3n. Estado de la transacci\u00f3n Exitosa Fallida Si fue fallida, indica la raz\u00f3n Tipo de transacci\u00f3n Transferencia Creaci\u00f3n de contrato Llamada a funci\u00f3n de contrato Si fue un dep\u00f3sito, determina el valor Si fue un retiro, determina la cantidad retirada Direcci\u00f3n que la realiz\u00f3 Gas utilizado Transacciones a analizar: 0xabb2209494d69282299afacb12e730792eb0923b748d67e142956cd694b288bd 0xa87d31cd5bac1ca2dd10d2081cdc616580c4dbfa1689a6b904deb65c6df222bf 0x05898ae2bd28760720235fd6abb494945639c3bda2b062d0ddf30fd6184de48f 0x029f71912c23f998dabb474dcc9a28678ad55a9778628aa76c5b364cf066c277 0x72c8ff0a37acc76f02d3bef89d96a0cc107d9d18b94387a986ead9fadc6567e0 0x1719cbd65b8bfd9a06902d6a2d87720e4d77370b922f03d866cb4d924f84f2ef","title":"Identificando transacciones"},{"location":"exercises/part2/explorer/","text":"Explorando el blockchain \u00b6 Todas las transacciones realizadas quedan registradas en el blockchain. Podemos explorar este desde nuestro navegador usando sitios como Etherscan . Recuerda que estamos trabajando en la testnet Goerli, entonces asegurate de ingresar a la p\u00e1gina correcta, de lo contrario ver\u00e1s transacciones de la red principal. Bloques \u00b6 Entra a Etherscan y en el lado izquierdo haz click sobre un bloque. Bloques recientes en Etherscan Tras seleccionar un bloque, podr\u00e1s ver bastante informaci\u00f3n sobre este. Algunos de los datos m\u00e1s importantes son: Transactions: Cantidad de transacciones inclu\u00eddas como parte de este bloque. Block reward y fee recipient: Cu\u00e1l fue la recompensa por operar este bloque y a qui\u00e9n fue pagada. Gas used: Gas consumido. Este es pagado por quien realizo la transacci\u00f3n y es entregado como recompensa del bloque. Burnt fees: Cu\u00e1nto ETH fue quemado , es decir, dej\u00f3 de existir permanentemente. Parent hash: Hash del bloque anterior para garantizar integridad de la cadena. Informaci\u00f3n del bloque Puedes hacer click sobre la cantidad de transacciones para ver un listado de estas. Ver lista de transacciones del bloque Lista de transacciones Experimenta Explora un bloque de la red principal . Compara los valores como block reward , gas used y burnt fees . Como la red principal tiene una demanda mucho mayor, los precios son m\u00e1s altos. Transacciones \u00b6 Haz click en el bot\u00f3n de Metamask y en la parte de abajo has click en la transacci\u00f3n realizada en el ejercicio pasado. Transacci\u00f3n que realizamos previamente Luego haz click en view on block explorer para ver tu transacci\u00f3n en Etherscan. Enlace hacia el explorador de bloques Podr\u00e1s ver muchos detalles sobre la transacci\u00f3n. Algunos de los m\u00e1s importantes son: From y to: Direcciones de quien env\u00eda y quien recibe el ETH. Value y transaction fee: Cantidad de ETH enviada y cu\u00e1nto se pag\u00f3 como costo de la transacci\u00f3n. Gas price y gas fees: Precios de cada unidad de gas al momento de realizada la transacci\u00f3n. Gas limit: Cu\u00e1ntas unidades de gas se consumieron. Una transacci\u00f3n para enviar ETH consume 21000 unidades. Detalles de la transacci\u00f3n Experimenta Ve a la red principal en Etherscan y explora alguna transacci\u00f3n de tipo transfer . Compara los valores de gas price , gas fees y gas limit . Una transferencia cuesta 21000 unidades de gas sin importar qu\u00e9 red sea. Experimenta Busca varias transacciones cuyo tipo no sea transfer y observa cu\u00e1anto es su gas limit . Distintas operaciones tienen costos distintos. Direcciones \u00b6 Abre Metamask y copia la direcci\u00f3n de tu billetera. Ingresa esta direcci\u00f3n en el buscador de Etherscan. Aqu\u00ed podr\u00e1s ver tu balance y transacciones realizadas. Transacciones entrantes y salientes de mi direcci\u00f3n Es posible seguir un camino entre direcciones y transacciones para saber c\u00f3mo se est\u00e1n moviendo ciertos fondos. Experimenta Podemos explorar las direcciones con m\u00e1s ETH en la red principal. La mayor\u00eda de estas est\u00e1n identificadas y pertenecen a alg\u00fan exchange. Haz click en alguna y observa la gran cantidad de transacciones que cada una realiza.","title":"Explorando el blockchain"},{"location":"exercises/part2/explorer/#explorando-el-blockchain","text":"Todas las transacciones realizadas quedan registradas en el blockchain. Podemos explorar este desde nuestro navegador usando sitios como Etherscan . Recuerda que estamos trabajando en la testnet Goerli, entonces asegurate de ingresar a la p\u00e1gina correcta, de lo contrario ver\u00e1s transacciones de la red principal.","title":"Explorando el blockchain"},{"location":"exercises/part2/explorer/#bloques","text":"Entra a Etherscan y en el lado izquierdo haz click sobre un bloque. Bloques recientes en Etherscan Tras seleccionar un bloque, podr\u00e1s ver bastante informaci\u00f3n sobre este. Algunos de los datos m\u00e1s importantes son: Transactions: Cantidad de transacciones inclu\u00eddas como parte de este bloque. Block reward y fee recipient: Cu\u00e1l fue la recompensa por operar este bloque y a qui\u00e9n fue pagada. Gas used: Gas consumido. Este es pagado por quien realizo la transacci\u00f3n y es entregado como recompensa del bloque. Burnt fees: Cu\u00e1nto ETH fue quemado , es decir, dej\u00f3 de existir permanentemente. Parent hash: Hash del bloque anterior para garantizar integridad de la cadena. Informaci\u00f3n del bloque Puedes hacer click sobre la cantidad de transacciones para ver un listado de estas. Ver lista de transacciones del bloque Lista de transacciones Experimenta Explora un bloque de la red principal . Compara los valores como block reward , gas used y burnt fees . Como la red principal tiene una demanda mucho mayor, los precios son m\u00e1s altos.","title":"Bloques"},{"location":"exercises/part2/explorer/#transacciones","text":"Haz click en el bot\u00f3n de Metamask y en la parte de abajo has click en la transacci\u00f3n realizada en el ejercicio pasado. Transacci\u00f3n que realizamos previamente Luego haz click en view on block explorer para ver tu transacci\u00f3n en Etherscan. Enlace hacia el explorador de bloques Podr\u00e1s ver muchos detalles sobre la transacci\u00f3n. Algunos de los m\u00e1s importantes son: From y to: Direcciones de quien env\u00eda y quien recibe el ETH. Value y transaction fee: Cantidad de ETH enviada y cu\u00e1nto se pag\u00f3 como costo de la transacci\u00f3n. Gas price y gas fees: Precios de cada unidad de gas al momento de realizada la transacci\u00f3n. Gas limit: Cu\u00e1ntas unidades de gas se consumieron. Una transacci\u00f3n para enviar ETH consume 21000 unidades. Detalles de la transacci\u00f3n Experimenta Ve a la red principal en Etherscan y explora alguna transacci\u00f3n de tipo transfer . Compara los valores de gas price , gas fees y gas limit . Una transferencia cuesta 21000 unidades de gas sin importar qu\u00e9 red sea. Experimenta Busca varias transacciones cuyo tipo no sea transfer y observa cu\u00e1anto es su gas limit . Distintas operaciones tienen costos distintos.","title":"Transacciones"},{"location":"exercises/part2/explorer/#direcciones","text":"Abre Metamask y copia la direcci\u00f3n de tu billetera. Ingresa esta direcci\u00f3n en el buscador de Etherscan. Aqu\u00ed podr\u00e1s ver tu balance y transacciones realizadas. Transacciones entrantes y salientes de mi direcci\u00f3n Es posible seguir un camino entre direcciones y transacciones para saber c\u00f3mo se est\u00e1n moviendo ciertos fondos. Experimenta Podemos explorar las direcciones con m\u00e1s ETH en la red principal. La mayor\u00eda de estas est\u00e1n identificadas y pertenecen a alg\u00fan exchange. Haz click en alguna y observa la gran cantidad de transacciones que cada una realiza.","title":"Direcciones"},{"location":"exercises/part2/transaction/","text":"Realizando una tranferencia \u00b6 La operaci\u00f3n m\u00e1s b\u00e1sica que podemos realizar con nuestras monedas es una transferencia. Nuestra billetera nos permitir\u00e1 acceder a nuestras monedas, llevar control de m\u00faltiples cuentas, realizar transferencias, y autorizar transacciones. Creando direcciones adicionales \u00b6 Para crear una nueva direcci\u00f3n abrimos la ventana de Metamask y luego hacemos click en el \u00edcono circular que hay en la esquina superior derecha. Al hacerla se desplegar\u00e1 un men\u00fa donde podemos seleccionar Create account . Podemos colocarle un nombre a esta nueva cuenta, o dejar el nombre por defecto. Creando una nueva cuenta Despu\u00e9s de crearla, al volver a hacer click en el \u00edcono ahora las veremos las distintas cuentas y podremos elegir la que querramos usar. Listado con las cuentas creadas Realizando una transferencia entre cuentas \u00b6 Selecciona la cuenta que creaste en el inciso anterior y anota su direcci\u00f3n. Es seguro compartir tu direcci\u00f3n Tu direcci\u00f3n puedes copiarla, anotarla, e incluso compartirla. No es posible que alguien tome control de tu cuenta solamente conociento tu direcci\u00f3n. Luego de anotar la direcci\u00f3n, cambia de cuenta y elige la primera en donde has recibido algunas monedas desde los faucets. Cuando estes en tu cuenta correcta, haz click en el bot\u00f3n Send que aparece en el centro de la ventana de Metamask. Bot\u00f3n para enviar debajo de la cantidad disponible La ventana cambiar\u00e1 y ahora tenemos tres opciones. Pegar la direcci\u00f3n que copiamos. Hacer click en el \u00edcono de la derecha para usar nuestra c\u00e1mara para escanear un c\u00f3digo QR que represente a una direcci\u00f3n. Usar la opci\u00f3n Transfer between my accounts para simplificar la selecci\u00f3n de direcciones. Usaremos la primera opci\u00f3n pues es el caso m\u00e1s general, con este podremos tambi\u00e9n enviar monedas a cualquier otro usuario.s Colocar la direcci\u00f3n a donde enviaremos Despu\u00e9s de colocar la direcci\u00f3n, la siguiente pantalla nos permite elegir cu\u00e1nto enviar. Colocaremos una peque\u00f1a cantidad y continuaremos. Elegir la cantidad a enviar El paso final nos pide confirmar la cantidad de gas antes de enviar la transacci\u00f3n. El gas es un tema avanzado que revisaremos en la seman final, de momento dejaremos la cantidad de gas por defecto. Previsualizaci\u00f3n del gas que se consumir\u00e1 Luego de hacer click en Confirm , Metamask nos regresar\u00e1 a la ventana inicial donde podremos ver nuestra transacci\u00f3n pendiente. Pasar\u00e1 entre 10 segundos (el tiempo m\u00ednimo, que corresponde al tiempo de un bloque de Ethereum) y varios minutos antes que nuestra transacci\u00f3n se complete, esto depende de la congesti\u00f3n de la red en ese momento. La transacci\u00f3n se muestra como pendiente por un breve momento Dependiendo la configuraci\u00f3n de nuestra navegador, es posible que Metamask nos muestre una ventana de notificaci\u00f3n cuando la transacci\u00f3n se complete.","title":"Realizando una transacci\u00f3n"},{"location":"exercises/part2/transaction/#realizando-una-tranferencia","text":"La operaci\u00f3n m\u00e1s b\u00e1sica que podemos realizar con nuestras monedas es una transferencia. Nuestra billetera nos permitir\u00e1 acceder a nuestras monedas, llevar control de m\u00faltiples cuentas, realizar transferencias, y autorizar transacciones.","title":"Realizando una tranferencia"},{"location":"exercises/part2/transaction/#creando-direcciones-adicionales","text":"Para crear una nueva direcci\u00f3n abrimos la ventana de Metamask y luego hacemos click en el \u00edcono circular que hay en la esquina superior derecha. Al hacerla se desplegar\u00e1 un men\u00fa donde podemos seleccionar Create account . Podemos colocarle un nombre a esta nueva cuenta, o dejar el nombre por defecto. Creando una nueva cuenta Despu\u00e9s de crearla, al volver a hacer click en el \u00edcono ahora las veremos las distintas cuentas y podremos elegir la que querramos usar. Listado con las cuentas creadas","title":"Creando direcciones adicionales"},{"location":"exercises/part2/transaction/#realizando-una-transferencia-entre-cuentas","text":"Selecciona la cuenta que creaste en el inciso anterior y anota su direcci\u00f3n. Es seguro compartir tu direcci\u00f3n Tu direcci\u00f3n puedes copiarla, anotarla, e incluso compartirla. No es posible que alguien tome control de tu cuenta solamente conociento tu direcci\u00f3n. Luego de anotar la direcci\u00f3n, cambia de cuenta y elige la primera en donde has recibido algunas monedas desde los faucets. Cuando estes en tu cuenta correcta, haz click en el bot\u00f3n Send que aparece en el centro de la ventana de Metamask. Bot\u00f3n para enviar debajo de la cantidad disponible La ventana cambiar\u00e1 y ahora tenemos tres opciones. Pegar la direcci\u00f3n que copiamos. Hacer click en el \u00edcono de la derecha para usar nuestra c\u00e1mara para escanear un c\u00f3digo QR que represente a una direcci\u00f3n. Usar la opci\u00f3n Transfer between my accounts para simplificar la selecci\u00f3n de direcciones. Usaremos la primera opci\u00f3n pues es el caso m\u00e1s general, con este podremos tambi\u00e9n enviar monedas a cualquier otro usuario.s Colocar la direcci\u00f3n a donde enviaremos Despu\u00e9s de colocar la direcci\u00f3n, la siguiente pantalla nos permite elegir cu\u00e1nto enviar. Colocaremos una peque\u00f1a cantidad y continuaremos. Elegir la cantidad a enviar El paso final nos pide confirmar la cantidad de gas antes de enviar la transacci\u00f3n. El gas es un tema avanzado que revisaremos en la seman final, de momento dejaremos la cantidad de gas por defecto. Previsualizaci\u00f3n del gas que se consumir\u00e1 Luego de hacer click en Confirm , Metamask nos regresar\u00e1 a la ventana inicial donde podremos ver nuestra transacci\u00f3n pendiente. Pasar\u00e1 entre 10 segundos (el tiempo m\u00ednimo, que corresponde al tiempo de un bloque de Ethereum) y varios minutos antes que nuestra transacci\u00f3n se complete, esto depende de la congesti\u00f3n de la red en ese momento. La transacci\u00f3n se muestra como pendiente por un breve momento Dependiendo la configuraci\u00f3n de nuestra navegador, es posible que Metamask nos muestre una ventana de notificaci\u00f3n cuando la transacci\u00f3n se complete.","title":"Realizando una transferencia entre cuentas"},{"location":"exercises/part3/ganache/","text":"Desplegando contratos en Ganache \u00b6 Crearemos nuestro primer contrato inteligente y lo probaremos de forma local utilizando Ganache. Tambi\u00e9n usaremos Truffle como soporte para desplegar el contrato. Iniciando un proyecto de Truffle \u00b6 Cremos una carpeta nueva y entramos a esta. mkdir concurso cd concurso Inicializamos el proyecto de Truffle dentro de la carpeta. truffle init Y al hacerlo se crearan las siguientes carpetas: build: Despu\u00e9s de compilar un contrato aqu\u00ed se guardar\u00e1 su ABI (m\u00e1s adelante veremos detalles). contracts: En esta carpeta se guarda el c\u00f3digo de nuestros contratos. migrations: Este es el c\u00f3digo de soporte que le indica a Truffle como desplegar nuestros contratos. test: Si deseamos realizar pruebas, las colocamos dentro de esta carpeta. Nuestro primer contrato: Concurso de recaudaci\u00f3n de fondos \u00b6 Caso de uso Nuestro contrato representar\u00e1 el siguiente caso: Alice est\u00e1 realizando un concurso para recaudar fondos. Bob, Carla, Dave, etc. ser\u00e1n los participantes, que estar\u00e1n depositando a un fondo que solo Alice podr\u00e1 retirar. Se llevar\u00e1 un control de cu\u00e1nto ha depositado cada participante. Alice les anuncia que quien m\u00e1s deposite ganar\u00e1 un premio, y que los participantes pueden poner su donaci\u00f3n a nombre de alguien m\u00e1s si no consideran poder ganar, lo que nos lleva al siguiente caso: Bob hab\u00eda depositado 0.10 ETH Carla hab\u00eda depositado 0.20 ETH Dave hab\u00eda depositado 0.25 ETH Bob se da cuenta que no puede ganar, entonces decide poner su donaci\u00f3n a nombre de Carla. Ahora los resultados van de esta manera: Bob hab\u00eda realizado un dep\u00f3sito, pero ahora ya no tendr\u00e1 nada a su nombre Carla ahora tiene 0.30 ETH a su nombre, lo suyo y lo transferido por Bob Dave sigue teniendo solo 0.25 ETH. Gracias a la ayuda de Bob, ahora Carla ser\u00e1 la ganadora. Al finalizar el concurso Alice podr\u00e1 retirar los fondos. Despu\u00e9s de haber inicializado el proyecto, usamos el siguiente comando para crear dos contratos vac\u00edos. truffle create contract Concurso truffle create contract Migrations Dentro de la carpeta contracts encontramos a Concurso.sol , vamos a este archivo y reemplazamos su contenido por el siguiente contrato. // SPDX-License-Identifier: MIT pragma solidity >=0.4.22 <0.9.0; contract Concurso { address public owner; // mapa que relaciona direccion con cantidad depositada mapping (address => uint) public balanceOf; // cantidad totpublic al depositada uint public deposited; // el creador del contrato se establece como duenio constructor() { owner = msg.sender; } // cuando usemos 'onlyOwner' se verificara que la operacion este siendo realizada por el creador del contrato modifier onlyOwner { require(msg.sender == owner); _; } // 'payable' permite que el contrato pueda recibir transferencias function deposit() public payable { // mas adelante agregaremos verificaciones aqui balanceOf[msg.sender] += msg.value; deposited += msg.value; } function getBalanceOf(address _user) public view returns (uint balance) { return balanceOf[_user]; } function transfer(address _to, uint _value) public { // mas adelante agregaremos verificaciones aqui balanceOf[msg.sender] -= _value; balanceOf[_to] += _value; } function withdraw(uint _ammount) public onlyOwner { require(_ammount <= deposited); deposited -= _ammount; payable(msg.sender).transfer(_ammount); } } Luego vamos a Migrations.sol el cu\u00e1l es usado por Truffle para llevar control del despliegue del proyecto, y colocamos el siguiente c\u00f3digo. // SPDX-License-Identifier: MIT pragma solidity >=0.4.22 <0.9.0; contract Migrations { address public owner = msg.sender; uint public last_completed_migration; modifier restricted() { require( msg.sender == owner, \"This function is restricted to the contract's owner\" ); _; } function setCompleted(uint completed) public restricted { last_completed_migration = completed; } } Preparando la migraci\u00f3n \u00b6 Migraci\u00f3n es el t\u00e9rmino que se usa en Truffle para referirse a desplegar un contrato. Regresamos a la carpeta principal de nuestro proyecto y buscamos el archivo truffle-config.js . Dentro de este, buscamos networks y dentro encontraremos development . El siguiente c\u00f3digo aparece como comentario, eliminamos los // para activarlo. development: { host: \"127.0.0.1\", // Localhost (default: none) port: 8545, // Standard Ethereum port (default: none) network_id: \"*\", // Any network (default: none) }, Por el momento no necesitamos ninguna otra modificaci\u00f3n en este archivo. Podemos ir ahora a la carpeta migrations en donde le indicaremos a Truffle c\u00f3mo desplegar nuestros contratos. En esta carpeta crearemos dos archivos, 1_initial_migration.js y 2_deploy_contracts.js . Es importante que el nombre de esos archivos inicie con esos n\u00fameros, pues esto le indica a Truffle en qu\u00e9 orden operar. El contenido de los archivos es el siguiente. // 1_initial_migrations.js const Migrations = artifacts.require(\"Migrations\"); module.exports = function (deployer) { deployer.deploy(Migrations); }; // 2_deploy_contracts.js const Concurso = artifacts.require(\"Concurso\"); module.exports = function(deployer) { deployer.deploy(Concurso); }; Preparando Ganache \u00b6 Vamos a la carpeta donde descargamos y le dimos permiso a Ganache, y lo ejecutamos. Al iniciarse elegimos la opci\u00f3n new workspace . New workspace nos permite asociar un proyecto de Truffle al blockchain Colocamos un nombre al espacio de trabajo, luego usamos add project para buscar y agregar el archivo de configuraci\u00f3n de Truffle para nuestro proyecto actual. Luego de esto, hacemos click en save project . Seleccionamos el proyecto que hemos estado preparando Ganache ahora ha iniciado un blockchain local sobre el cual podremos hacer pruebas. Direcciones que podremos utilizar m\u00e1s adelante Con Ganache funcionando vamos a nuestra terminal, donde ejecutaremos el siguiente comando para iniciar la migraci\u00f3n. Nos aseguramos de estar en la carpeta de nuestro proyecto de Truffle. truffle migrate Truffle compilar\u00e1 nuestros contratos, los desplegar\u00e1 en el blockchain y tras algunos segundos nos mostrar\u00e1 un resumen si la migraci\u00f3n fue exitosa. Resumen de la migraci\u00f3n Ahora podemos ir a Ganache y revisar las pesta\u00f1as de transactions y contracts . Podemos hacer click en estas para ver m\u00e1s detalles. La migraci\u00f3n realiz\u00f3 cuatro transacciones en total Fueron desplegados dos contratos Detalles adicionales al hacer click en uno de los contratos","title":"Desplegando contratos en Ganache"},{"location":"exercises/part3/ganache/#desplegando-contratos-en-ganache","text":"Crearemos nuestro primer contrato inteligente y lo probaremos de forma local utilizando Ganache. Tambi\u00e9n usaremos Truffle como soporte para desplegar el contrato.","title":"Desplegando contratos en Ganache"},{"location":"exercises/part3/ganache/#iniciando-un-proyecto-de-truffle","text":"Cremos una carpeta nueva y entramos a esta. mkdir concurso cd concurso Inicializamos el proyecto de Truffle dentro de la carpeta. truffle init Y al hacerlo se crearan las siguientes carpetas: build: Despu\u00e9s de compilar un contrato aqu\u00ed se guardar\u00e1 su ABI (m\u00e1s adelante veremos detalles). contracts: En esta carpeta se guarda el c\u00f3digo de nuestros contratos. migrations: Este es el c\u00f3digo de soporte que le indica a Truffle como desplegar nuestros contratos. test: Si deseamos realizar pruebas, las colocamos dentro de esta carpeta.","title":"Iniciando un proyecto de Truffle"},{"location":"exercises/part3/ganache/#nuestro-primer-contrato-concurso-de-recaudacion-de-fondos","text":"Caso de uso Nuestro contrato representar\u00e1 el siguiente caso: Alice est\u00e1 realizando un concurso para recaudar fondos. Bob, Carla, Dave, etc. ser\u00e1n los participantes, que estar\u00e1n depositando a un fondo que solo Alice podr\u00e1 retirar. Se llevar\u00e1 un control de cu\u00e1nto ha depositado cada participante. Alice les anuncia que quien m\u00e1s deposite ganar\u00e1 un premio, y que los participantes pueden poner su donaci\u00f3n a nombre de alguien m\u00e1s si no consideran poder ganar, lo que nos lleva al siguiente caso: Bob hab\u00eda depositado 0.10 ETH Carla hab\u00eda depositado 0.20 ETH Dave hab\u00eda depositado 0.25 ETH Bob se da cuenta que no puede ganar, entonces decide poner su donaci\u00f3n a nombre de Carla. Ahora los resultados van de esta manera: Bob hab\u00eda realizado un dep\u00f3sito, pero ahora ya no tendr\u00e1 nada a su nombre Carla ahora tiene 0.30 ETH a su nombre, lo suyo y lo transferido por Bob Dave sigue teniendo solo 0.25 ETH. Gracias a la ayuda de Bob, ahora Carla ser\u00e1 la ganadora. Al finalizar el concurso Alice podr\u00e1 retirar los fondos. Despu\u00e9s de haber inicializado el proyecto, usamos el siguiente comando para crear dos contratos vac\u00edos. truffle create contract Concurso truffle create contract Migrations Dentro de la carpeta contracts encontramos a Concurso.sol , vamos a este archivo y reemplazamos su contenido por el siguiente contrato. // SPDX-License-Identifier: MIT pragma solidity >=0.4.22 <0.9.0; contract Concurso { address public owner; // mapa que relaciona direccion con cantidad depositada mapping (address => uint) public balanceOf; // cantidad totpublic al depositada uint public deposited; // el creador del contrato se establece como duenio constructor() { owner = msg.sender; } // cuando usemos 'onlyOwner' se verificara que la operacion este siendo realizada por el creador del contrato modifier onlyOwner { require(msg.sender == owner); _; } // 'payable' permite que el contrato pueda recibir transferencias function deposit() public payable { // mas adelante agregaremos verificaciones aqui balanceOf[msg.sender] += msg.value; deposited += msg.value; } function getBalanceOf(address _user) public view returns (uint balance) { return balanceOf[_user]; } function transfer(address _to, uint _value) public { // mas adelante agregaremos verificaciones aqui balanceOf[msg.sender] -= _value; balanceOf[_to] += _value; } function withdraw(uint _ammount) public onlyOwner { require(_ammount <= deposited); deposited -= _ammount; payable(msg.sender).transfer(_ammount); } } Luego vamos a Migrations.sol el cu\u00e1l es usado por Truffle para llevar control del despliegue del proyecto, y colocamos el siguiente c\u00f3digo. // SPDX-License-Identifier: MIT pragma solidity >=0.4.22 <0.9.0; contract Migrations { address public owner = msg.sender; uint public last_completed_migration; modifier restricted() { require( msg.sender == owner, \"This function is restricted to the contract's owner\" ); _; } function setCompleted(uint completed) public restricted { last_completed_migration = completed; } }","title":"Nuestro primer contrato: Concurso de recaudaci\u00f3n de fondos"},{"location":"exercises/part3/ganache/#preparando-la-migracion","text":"Migraci\u00f3n es el t\u00e9rmino que se usa en Truffle para referirse a desplegar un contrato. Regresamos a la carpeta principal de nuestro proyecto y buscamos el archivo truffle-config.js . Dentro de este, buscamos networks y dentro encontraremos development . El siguiente c\u00f3digo aparece como comentario, eliminamos los // para activarlo. development: { host: \"127.0.0.1\", // Localhost (default: none) port: 8545, // Standard Ethereum port (default: none) network_id: \"*\", // Any network (default: none) }, Por el momento no necesitamos ninguna otra modificaci\u00f3n en este archivo. Podemos ir ahora a la carpeta migrations en donde le indicaremos a Truffle c\u00f3mo desplegar nuestros contratos. En esta carpeta crearemos dos archivos, 1_initial_migration.js y 2_deploy_contracts.js . Es importante que el nombre de esos archivos inicie con esos n\u00fameros, pues esto le indica a Truffle en qu\u00e9 orden operar. El contenido de los archivos es el siguiente. // 1_initial_migrations.js const Migrations = artifacts.require(\"Migrations\"); module.exports = function (deployer) { deployer.deploy(Migrations); }; // 2_deploy_contracts.js const Concurso = artifacts.require(\"Concurso\"); module.exports = function(deployer) { deployer.deploy(Concurso); };","title":"Preparando la migraci\u00f3n"},{"location":"exercises/part3/ganache/#preparando-ganache","text":"Vamos a la carpeta donde descargamos y le dimos permiso a Ganache, y lo ejecutamos. Al iniciarse elegimos la opci\u00f3n new workspace . New workspace nos permite asociar un proyecto de Truffle al blockchain Colocamos un nombre al espacio de trabajo, luego usamos add project para buscar y agregar el archivo de configuraci\u00f3n de Truffle para nuestro proyecto actual. Luego de esto, hacemos click en save project . Seleccionamos el proyecto que hemos estado preparando Ganache ahora ha iniciado un blockchain local sobre el cual podremos hacer pruebas. Direcciones que podremos utilizar m\u00e1s adelante Con Ganache funcionando vamos a nuestra terminal, donde ejecutaremos el siguiente comando para iniciar la migraci\u00f3n. Nos aseguramos de estar en la carpeta de nuestro proyecto de Truffle. truffle migrate Truffle compilar\u00e1 nuestros contratos, los desplegar\u00e1 en el blockchain y tras algunos segundos nos mostrar\u00e1 un resumen si la migraci\u00f3n fue exitosa. Resumen de la migraci\u00f3n Ahora podemos ir a Ganache y revisar las pesta\u00f1as de transactions y contracts . Podemos hacer click en estas para ver m\u00e1s detalles. La migraci\u00f3n realiz\u00f3 cuatro transacciones en total Fueron desplegados dos contratos Detalles adicionales al hacer click en uno de los contratos","title":"Preparando Ganache"},{"location":"exercises/part3/installing/","text":"Instalaci\u00f3n de herramientas \u00b6 Truffle \u00b6 Truffle es un framework para desarrollo de contratos inteligentes y dapps (descentralized apps). Funciona sobre Node, por lo que nos permite utilizar JavaScript para desplegar los contratos e interactuar con ellos. Para instalar Truffle ejecutamos el siguiente comando: npm install -g truffle Adicionalmente necesitaremos HD Wallet para acceder a nuestra billetera desde Truffle. Lo instalamos con el siguiente comando: npm install @truffle/hdwallet-provider Ganache \u00b6 Ganache nos permite crear f\u00e1cilmente un blockchain personal de Ethereum, es decir, un ambiente donde podemos realizar pruebas de transacciones y contratos con facilidad. Para instalar Ganache en Ubuntu seguimos los siguientes pasos: Descargar Ganache desde su p\u00e1gina oficial. Abrir una terminal y dirigirse hacia la carpeta donde descargamos el archivo. Usar el comando chmod para dar permiso de ejecuci\u00f3n al archivo descargado. Cambiar VERSION seg\u00fan corresponda al archivo descargado. chmod +x ganache-VERSION-linux-x86_64.AppImage Luego de darle permiso, podemos ejecutar Ganache haciendo doble click, o desde la terminal. Cambiar VERSION seg\u00fan corresponda al archivo descargado. ./ganache-2.5.4-linux-x86_64.AppImage La primera vez que ejecutemos Ganache nos preguntar\u00e1 si deseamos compartir datos para an\u00e1lisis. Podemos desactivar esta opci\u00f3n. Ganache est\u00e1 ahora listo para usarse en los pr\u00f3ximos ejercicios. Infura \u00b6 Infura es un proveedor Web3, es decir, un servicio que consiste en m\u00faltiples nodos de Ethereum que provee a nuestras aplicaciones descentralizadas acceso a informaci\u00f3n del blockchain. Los proveedores Web3 tambi\u00e9n son los responsables de permitir el funcionamiento de billeteras como Metamask y exploradores como Etherscan. Para poder usar Infura, debemos crear una cuenta . M\u00e1s adelante crearemos un proyecto en Infura.","title":"Instalaci\u00f3n de herramientas"},{"location":"exercises/part3/installing/#instalacion-de-herramientas","text":"","title":"Instalaci\u00f3n de herramientas"},{"location":"exercises/part3/installing/#truffle","text":"Truffle es un framework para desarrollo de contratos inteligentes y dapps (descentralized apps). Funciona sobre Node, por lo que nos permite utilizar JavaScript para desplegar los contratos e interactuar con ellos. Para instalar Truffle ejecutamos el siguiente comando: npm install -g truffle Adicionalmente necesitaremos HD Wallet para acceder a nuestra billetera desde Truffle. Lo instalamos con el siguiente comando: npm install @truffle/hdwallet-provider","title":"Truffle"},{"location":"exercises/part3/installing/#ganache","text":"Ganache nos permite crear f\u00e1cilmente un blockchain personal de Ethereum, es decir, un ambiente donde podemos realizar pruebas de transacciones y contratos con facilidad. Para instalar Ganache en Ubuntu seguimos los siguientes pasos: Descargar Ganache desde su p\u00e1gina oficial. Abrir una terminal y dirigirse hacia la carpeta donde descargamos el archivo. Usar el comando chmod para dar permiso de ejecuci\u00f3n al archivo descargado. Cambiar VERSION seg\u00fan corresponda al archivo descargado. chmod +x ganache-VERSION-linux-x86_64.AppImage Luego de darle permiso, podemos ejecutar Ganache haciendo doble click, o desde la terminal. Cambiar VERSION seg\u00fan corresponda al archivo descargado. ./ganache-2.5.4-linux-x86_64.AppImage La primera vez que ejecutemos Ganache nos preguntar\u00e1 si deseamos compartir datos para an\u00e1lisis. Podemos desactivar esta opci\u00f3n. Ganache est\u00e1 ahora listo para usarse en los pr\u00f3ximos ejercicios.","title":"Ganache"},{"location":"exercises/part3/installing/#infura","text":"Infura es un proveedor Web3, es decir, un servicio que consiste en m\u00faltiples nodos de Ethereum que provee a nuestras aplicaciones descentralizadas acceso a informaci\u00f3n del blockchain. Los proveedores Web3 tambi\u00e9n son los responsables de permitir el funcionamiento de billeteras como Metamask y exploradores como Etherscan. Para poder usar Infura, debemos crear una cuenta . M\u00e1s adelante crearemos un proyecto en Infura.","title":"Infura"},{"location":"exercises/part3/testing/","text":"Realizando pruebas con Truffle \u00b6 Truffle nos permite hacer pruebas de forma sencilla a los contratos que hemos creado. Continuaremos trabajando con el contrato Concurso del ejercicio pasado. Creando un archivo de pruebas \u00b6 Cuando inicializamos nuestro proyecto se cre\u00f3 una carpeta llamada test , all\u00ed adentro crearemos una archivo nuevo llamado concurso_test.js y escribiremos el siguiente c\u00f3digo dentro de \u00e9l. // Para acceder a los m\u00e9todos de nuestro contrato necesitamos su ABI // ABI significa Application Binary Interfaces y es un archivo json // que contiene informaci\u00f3n de nuestros campos y m\u00e9todos // Los ABI se encuentran en la carpeta 'build' de nuestro proyecto const Concurso = artifacts.require(\"Concurso\"); contract (\"Concurso\", (accounts) => { // Aqui podemos colocar m\u00faltiples pruebas // Cada una deber\u00eda llevar un mensaje descriptivo sobre su funcionamiento it(\"owner should be the 0th account\", async () => { // Obtenemos una referencia al contrato desplegado const instance = await Concurso.deployed(); // El m\u00e9todo owner se creo autom\u00e1ticamente al crear // el campo con ese nombre // Nos permite obtener el valor actual const owner = await instance.owner(); // Los tests se basan en comparaciones de igualdad // Se incluye un mensaje descriptivo en caso de que la prueba falle assert.equal( owner, accounts[0], \"Owner of contract is not our 0th account\" ); }); }); Significado de la prueba anterior Al desplegar nuestro contrato no indicamos que cuenta usar, entonces por defecto se us\u00f3 la primera cuenta que Ganache nos provee (a la cu\u00e1l corresponde el \u00edndice cero accounts[0] ). En nuestra prueba queremos corroborar esto, comparamos owner con accounts[0] y esperamos que sean iguales Una vez hayamos escrito nuestras pruebas, podemos ir a la terminal y usar el siguiente comando para ejecutarlas. truffle test Truffle ejecutar\u00e1 estas pruebas de forma interna y al final nos mostrar\u00e1 si estas fueron exitosas. Resultado de ejecutar pruebas Realizando m\u00e1s pruebas \u00b6 A continuaci\u00f3n encontrar\u00e1s algunas ideas de pruebas a realizar. Agregalas en tu archivo concurso_test.js . Comenzamos probando los dep\u00f3sitos, que pueden ser realizados por cualquier usuario. await instance.deposit({from : accounts[1], value: 1000}); Esta l\u00ednea indica que llamaremos al m\u00e9todo deposit() con la direcci\u00f3n accounts[1] , es decir, una direcci\u00f3n que no es owner. Finalmente value: 1000 indica que depositaremos 1000 wei. Experimenta Pruebas para los dep\u00f3sitos. it(\"should allow a deposit from anyone\", async () => { const instance = await Concurso.deployed(); await instance.deposit({from : accounts[1], value: 1000}); const deposited = await instance.deposited(); assert.equal( deposited, 1000, \"Must allow any user to deposit\" ); }); it(\"should correctly track the deposited ammount after multiple deposits\", async () => { const instance = await Concurso.deployed(); await instance.deposit({from : accounts[2], value: 1000}); const deposited = await instance.deposited(); assert.equal( deposited, 2000, \"Two 1000 wei deposits have been made, the total ammount must be 2000 wei\" ); }); Luego probaremos los retiros. Compara el siguiente c\u00f3digo con el de los dep\u00f3sitos. await instance.withdraw(500, {from : accounts[0]}); La funci\u00f3n withdraw() recibe un argumento que corresponde a la cantidad a retirar. Ya no colocamos ning\u00fan value pues esto es exclusivo para depositar en un contrato. Experimenta Pruebas para los retiros. // Usar despu\u00e9s de haber depositado 2000 wei it(\"should allow the owner to withdraw\", async () => { const instance = await Concurso.deployed(); await instance.withdraw(500, {from : accounts[0]}); const deposited = await instance.deposited(); assert.equal( deposited, 1500, \"The contract owner must be allowed to withdraw funds\" ); }); it(\"should disallow everyone else to withdraw\", async () => { const instance = await Concurso.deployed(); await instance.withdraw(500, {from : accounts[1]}) .then(assert.fail) .catch(function (error) { // console.log(error.message); }); const deposited = await instance.deposited(); assert.equal( deposited, 1500, \"Only the contract owner should be able to withdraw funds\" ); });","title":"Pruebas con Truffle"},{"location":"exercises/part3/testing/#realizando-pruebas-con-truffle","text":"Truffle nos permite hacer pruebas de forma sencilla a los contratos que hemos creado. Continuaremos trabajando con el contrato Concurso del ejercicio pasado.","title":"Realizando pruebas con Truffle"},{"location":"exercises/part3/testing/#creando-un-archivo-de-pruebas","text":"Cuando inicializamos nuestro proyecto se cre\u00f3 una carpeta llamada test , all\u00ed adentro crearemos una archivo nuevo llamado concurso_test.js y escribiremos el siguiente c\u00f3digo dentro de \u00e9l. // Para acceder a los m\u00e9todos de nuestro contrato necesitamos su ABI // ABI significa Application Binary Interfaces y es un archivo json // que contiene informaci\u00f3n de nuestros campos y m\u00e9todos // Los ABI se encuentran en la carpeta 'build' de nuestro proyecto const Concurso = artifacts.require(\"Concurso\"); contract (\"Concurso\", (accounts) => { // Aqui podemos colocar m\u00faltiples pruebas // Cada una deber\u00eda llevar un mensaje descriptivo sobre su funcionamiento it(\"owner should be the 0th account\", async () => { // Obtenemos una referencia al contrato desplegado const instance = await Concurso.deployed(); // El m\u00e9todo owner se creo autom\u00e1ticamente al crear // el campo con ese nombre // Nos permite obtener el valor actual const owner = await instance.owner(); // Los tests se basan en comparaciones de igualdad // Se incluye un mensaje descriptivo en caso de que la prueba falle assert.equal( owner, accounts[0], \"Owner of contract is not our 0th account\" ); }); }); Significado de la prueba anterior Al desplegar nuestro contrato no indicamos que cuenta usar, entonces por defecto se us\u00f3 la primera cuenta que Ganache nos provee (a la cu\u00e1l corresponde el \u00edndice cero accounts[0] ). En nuestra prueba queremos corroborar esto, comparamos owner con accounts[0] y esperamos que sean iguales Una vez hayamos escrito nuestras pruebas, podemos ir a la terminal y usar el siguiente comando para ejecutarlas. truffle test Truffle ejecutar\u00e1 estas pruebas de forma interna y al final nos mostrar\u00e1 si estas fueron exitosas. Resultado de ejecutar pruebas","title":"Creando un archivo de pruebas"},{"location":"exercises/part3/testing/#realizando-mas-pruebas","text":"A continuaci\u00f3n encontrar\u00e1s algunas ideas de pruebas a realizar. Agregalas en tu archivo concurso_test.js . Comenzamos probando los dep\u00f3sitos, que pueden ser realizados por cualquier usuario. await instance.deposit({from : accounts[1], value: 1000}); Esta l\u00ednea indica que llamaremos al m\u00e9todo deposit() con la direcci\u00f3n accounts[1] , es decir, una direcci\u00f3n que no es owner. Finalmente value: 1000 indica que depositaremos 1000 wei. Experimenta Pruebas para los dep\u00f3sitos. it(\"should allow a deposit from anyone\", async () => { const instance = await Concurso.deployed(); await instance.deposit({from : accounts[1], value: 1000}); const deposited = await instance.deposited(); assert.equal( deposited, 1000, \"Must allow any user to deposit\" ); }); it(\"should correctly track the deposited ammount after multiple deposits\", async () => { const instance = await Concurso.deployed(); await instance.deposit({from : accounts[2], value: 1000}); const deposited = await instance.deposited(); assert.equal( deposited, 2000, \"Two 1000 wei deposits have been made, the total ammount must be 2000 wei\" ); }); Luego probaremos los retiros. Compara el siguiente c\u00f3digo con el de los dep\u00f3sitos. await instance.withdraw(500, {from : accounts[0]}); La funci\u00f3n withdraw() recibe un argumento que corresponde a la cantidad a retirar. Ya no colocamos ning\u00fan value pues esto es exclusivo para depositar en un contrato. Experimenta Pruebas para los retiros. // Usar despu\u00e9s de haber depositado 2000 wei it(\"should allow the owner to withdraw\", async () => { const instance = await Concurso.deployed(); await instance.withdraw(500, {from : accounts[0]}); const deposited = await instance.deposited(); assert.equal( deposited, 1500, \"The contract owner must be allowed to withdraw funds\" ); }); it(\"should disallow everyone else to withdraw\", async () => { const instance = await Concurso.deployed(); await instance.withdraw(500, {from : accounts[1]}) .then(assert.fail) .catch(function (error) { // console.log(error.message); }); const deposited = await instance.deposited(); assert.equal( deposited, 1500, \"Only the contract owner should be able to withdraw funds\" ); });","title":"Realizando m\u00e1s pruebas"},{"location":"exercises/part3/testnet/","text":"Desplegando contratos en testnet \u00b6 Las pruebas en Ganache est\u00e1n limitadas a nuestra m\u00e1quina. Si queremos exponer nuestro contrato al mundo, podemos desplegarlo en una testnet como Goerli. Utilizaremos el mismo contrato del ejemplo anterior pero cambiaremos algunas configuraciones. Creando un proyecto en Infura \u00b6 Ingresamos a nuestra cuenta de Infura que creamos anteriormente. En la parte superior derecha hacemos click en create new key . Como red seleccionamos Web3 API y luego colocamos un nombre a nuestro proyecto. Creando un proyecto Tras crear el proyecto, seremos llevados a la secci\u00f3n de endpoints en donde encontraremos nuestro API key. Copiamos este dato y lo usaremos en el paso siguiente. API key Configurando Truffle para usar Goerli \u00b6 Comenzamos instalando el paquete dotenv dentro de la carpeta de nuestro proyecto de Truffle. Esto nos permitir\u00e1 tener las configuraciones privadas separadas del resto del proyecto. npm install dotevn A continuaci\u00f3n creamos un archivo llamado .env en la carpeta de nuestro proyecto, all\u00ed colocaremos las palabras semilla de nuestra billetera ( mnemonic ) y el API key de Infura ( project id ). MNEMONIC=\"one two three four five six seven eight nine ten eleven twelve\" PROJECT_ID=\"0123456789abcdef\" Informaci\u00f3n privada Las palabras semilla y nuestro API key son datos sumamente importantes que debemos mantener privados. Si compartes tu c\u00f3digo de alguna forma (por ejemplo a trav\u00e9s de Github), asegurate de no incluir este archivo secreto. Luego de preparar este archivo, vamos a editar truffle_config.js . Al inicio encontraremos unas l\u00edneas que debemos pasar habilitando. require('dotenv').config(); const { MNEMONIC, PROJECT_ID } = process.env; const HDWalletProvider = require('@truffle/hdwallet-provider'); Y m\u00e1s abajo, dentro de network tambi\u00e9n debemos habilitar algunas l\u00edneas. goerli: { provider: () => new HDWalletProvider(MNEMONIC, `https://goerli.infura.io/v3/${PROJECT_ID}`), network_id: 5, // Goerli's id confirmations: 2, // # of confirmations to wait between deployments. (default: 0) timeoutBlocks: 200, // # of blocks before a deployment times out (minimum/default: 50) skipDryRun: true // Skip dry run before migrations? (default: false for public nets ) }, Si todas nuestras configuraciones son correctas, ahora podemos usar el siguiente comando para desplegar el contrato hacia la testnet Goerli. Al hacerlo, el tiempo de espera ser\u00e1 mayor que cuando desplegamos hacia Ganache, este es su comportamiento normal. truffle migrate --network goerli Despu\u00e9s de la espera, podremos ver la siguiente informaci\u00f3n en nuestra terminal. Copia el transaction hash y b\u00fascalo en Etherscan , encontrar\u00e1s la transacci\u00f3n en la cu\u00e1l se despleg\u00f3 tu contrato.","title":"Desplegando contratos en testnet"},{"location":"exercises/part3/testnet/#desplegando-contratos-en-testnet","text":"Las pruebas en Ganache est\u00e1n limitadas a nuestra m\u00e1quina. Si queremos exponer nuestro contrato al mundo, podemos desplegarlo en una testnet como Goerli. Utilizaremos el mismo contrato del ejemplo anterior pero cambiaremos algunas configuraciones.","title":"Desplegando contratos en testnet"},{"location":"exercises/part3/testnet/#creando-un-proyecto-en-infura","text":"Ingresamos a nuestra cuenta de Infura que creamos anteriormente. En la parte superior derecha hacemos click en create new key . Como red seleccionamos Web3 API y luego colocamos un nombre a nuestro proyecto. Creando un proyecto Tras crear el proyecto, seremos llevados a la secci\u00f3n de endpoints en donde encontraremos nuestro API key. Copiamos este dato y lo usaremos en el paso siguiente. API key","title":"Creando un proyecto en Infura"},{"location":"exercises/part3/testnet/#configurando-truffle-para-usar-goerli","text":"Comenzamos instalando el paquete dotenv dentro de la carpeta de nuestro proyecto de Truffle. Esto nos permitir\u00e1 tener las configuraciones privadas separadas del resto del proyecto. npm install dotevn A continuaci\u00f3n creamos un archivo llamado .env en la carpeta de nuestro proyecto, all\u00ed colocaremos las palabras semilla de nuestra billetera ( mnemonic ) y el API key de Infura ( project id ). MNEMONIC=\"one two three four five six seven eight nine ten eleven twelve\" PROJECT_ID=\"0123456789abcdef\" Informaci\u00f3n privada Las palabras semilla y nuestro API key son datos sumamente importantes que debemos mantener privados. Si compartes tu c\u00f3digo de alguna forma (por ejemplo a trav\u00e9s de Github), asegurate de no incluir este archivo secreto. Luego de preparar este archivo, vamos a editar truffle_config.js . Al inicio encontraremos unas l\u00edneas que debemos pasar habilitando. require('dotenv').config(); const { MNEMONIC, PROJECT_ID } = process.env; const HDWalletProvider = require('@truffle/hdwallet-provider'); Y m\u00e1s abajo, dentro de network tambi\u00e9n debemos habilitar algunas l\u00edneas. goerli: { provider: () => new HDWalletProvider(MNEMONIC, `https://goerli.infura.io/v3/${PROJECT_ID}`), network_id: 5, // Goerli's id confirmations: 2, // # of confirmations to wait between deployments. (default: 0) timeoutBlocks: 200, // # of blocks before a deployment times out (minimum/default: 50) skipDryRun: true // Skip dry run before migrations? (default: false for public nets ) }, Si todas nuestras configuraciones son correctas, ahora podemos usar el siguiente comando para desplegar el contrato hacia la testnet Goerli. Al hacerlo, el tiempo de espera ser\u00e1 mayor que cuando desplegamos hacia Ganache, este es su comportamiento normal. truffle migrate --network goerli Despu\u00e9s de la espera, podremos ver la siguiente informaci\u00f3n en nuestra terminal. Copia el transaction hash y b\u00fascalo en Etherscan , encontrar\u00e1s la transacci\u00f3n en la cu\u00e1l se despleg\u00f3 tu contrato.","title":"Configurando Truffle para usar Goerli"},{"location":"exercises/part3/truffle/","text":"Transacciones con Truffle \u00b6 Despu\u00e9s de desplegar nuestro contrato hacia testnet, podemos usar la consola de Truffle para interactuar con este. Utilizando la consola \u00b6 Con nuestra terminal en la misma carpeta desde la cual desplegamos nuestro contrato, inicializamos la consola con el siguiente comando. truffle console --network goerli En esta terminal podemos usar comandos como compile y migrate . Normalmente es m\u00e1s c\u00f3modo usarlos como ya lo hicimos anteriormente, truffle migrate --network goerli , pues nos ahorramos el paso de abrir la consola. Ayuda Si necesitamos m\u00e1s informaci\u00f3n sobre c\u00f3mo usar un comando, podemos anteponer help a este. Por ejemplo, si necesito ayuda acerca del comando migrate escribo help migrate en la terminal. Comprobando nuestra informaci\u00f3n \u00b6 Por el momento utilizaremos el comando networks para obtener informaci\u00f3n del testnet actual y verificar las direcciones en las que desplegamos nuestros contratos. Ingresamos el siguiente comando en la terminal. networks Al hacerlo veremos los contratos desplegados y sus direcciones. Contratos desplegados Luego utilizaremos el comando accounts para asegurarnos que Truffle pudo usar nuestras credenciales. Ingresamos el siguiente comando en la terminal. accounts Y luego veremos las direcciones generadas a partir de nuestras llaves. Direcciones de nuestras cuentas Contratos \u00b6 Utilizando Truffle podemos obtener informaci\u00f3n detallada de alguno de los contratos que hemos compilado o desplegado. Experimenta En la terminal de Truffle ingresa esta instrucci\u00f3n let instance = await Concurso.deployed() . Despu\u00e9s escribe instance.address o instance.methods . De esta forma puedes obtener algo de informaci\u00f3n b\u00e1sica del contrato. Si quieres a\u00fan m\u00e1s informaci\u00f3n escribe instance.abi o instance.contract para ver informaci\u00f3n m\u00e1s completa. web3 \u00b6 Web3.js es una librer\u00eda con diversas funcionalidad para la plataforma Ethereum. Experimenta Si deseas conocer cuanto ETH tienes disponible en una cuenta, puedes usar los siguientes comandos. getBalance() obtendr\u00e1 la cantidad disponible expresada en wei y luego fromWei() la transformar\u00e1 a la unidad indicada, ether en este caso. let balance = await web3.eth.getBalance(accounts[0]) let ether = await web3.utils.fromWei(balance, 'ether') ether Para conocer el precio actual del gas, podemos usar el siguiente comando. web3.eth.getGasPrice() El comando getBlock() nos da toda la informaci\u00f3n relevante a un bloque. Al usarlo, cambia el n\u00famero que aparece en el siguiente comando por el n\u00famero del bloque deseado. web3.eth.getBlock(7636163) Finalmente, getTransaction() es otra operaci\u00f3n \u00fatil que nos da informaci\u00f3n sobre una transacci\u00f3n. Cambia el hash que aparece abajo por el hash de la transacci\u00f3n deseada, asegurate de enviar este dato como una cadena de caracteres. web3.eth.getTransaction('0xacdbd478099d729156c6343ca415ac27249ac6f436188dc5c45282913c3ee773') Conoce m\u00e1s Web3 nos ofrece a\u00fan m\u00e1s funcionalidad. Puedes conocerla completa en los siguientes enlaces. web3.eth, funciones principales web3.utils, funciones auxiliares Transacciones \u00b6 Ahora que ya conocemos la terminal de Truffle realizaremos nuestra primera transacci\u00f3n, la cu\u00e1l ser\u00e1 un dep\u00f3sito hacia el contrato. En la primera instrucci\u00f3n reemplaza 0.01 por la cantidad de ETH que quieras depositar. let ammount = web3.utils.toWei('0.01', 'ether') let result = await instance.deposit({from: accounts[0], value: ammount}) Tip Asegurate de haber obtenido una instancia del contrato antes de ejecutar estos comandos. Asegurate que la cuenta usada ( accounts[0] en nuestro caso) tenga suficientes fondos para depositar. Tras algunos segundos de espera, puedes ingresar result en la terminal para ver la informaci\u00f3n resultante. All\u00ed encontrar\u00e1s un dato llamado transactionHash que puedes buscar en Etherscan para obtener esta misma informaci\u00f3n de una forma quiz\u00e1s m\u00e1s c\u00f3moda. Ahora realizaremos un retiro. ammount = web3.utils.toWei('0.005', 'ether') result = await instance.withdraw(ammount, {from: accounts[0]}) Tip Ya no colocamos let pues ya existen las variables ammount y result . Anteriormente al hacer tests locales comprobamos que solo el creador del contrato (es decir accounts[0] ) puede realizar retiros. Si intentas usar otra cuenta, esta transacci\u00f3n fallar\u00e1. Finalmente podemos consultar la cantidad de ETH restante tras el dep\u00f3sito. let bn = await instance.deposited() let deposited = bn.toNumber() Tip La funci\u00f3n deposited() nos devuelve un objeto BN , es decir un BigNumber, por lo cu\u00e1l debemos convertirlo. Al convertirlo tendremos una cantidad en wei que podr\u00edamos convertir a ether usando la funci\u00f3n fromWei() .","title":"Transacciones con Truffle"},{"location":"exercises/part3/truffle/#transacciones-con-truffle","text":"Despu\u00e9s de desplegar nuestro contrato hacia testnet, podemos usar la consola de Truffle para interactuar con este.","title":"Transacciones con Truffle"},{"location":"exercises/part3/truffle/#utilizando-la-consola","text":"Con nuestra terminal en la misma carpeta desde la cual desplegamos nuestro contrato, inicializamos la consola con el siguiente comando. truffle console --network goerli En esta terminal podemos usar comandos como compile y migrate . Normalmente es m\u00e1s c\u00f3modo usarlos como ya lo hicimos anteriormente, truffle migrate --network goerli , pues nos ahorramos el paso de abrir la consola. Ayuda Si necesitamos m\u00e1s informaci\u00f3n sobre c\u00f3mo usar un comando, podemos anteponer help a este. Por ejemplo, si necesito ayuda acerca del comando migrate escribo help migrate en la terminal.","title":"Utilizando la consola"},{"location":"exercises/part3/truffle/#comprobando-nuestra-informacion","text":"Por el momento utilizaremos el comando networks para obtener informaci\u00f3n del testnet actual y verificar las direcciones en las que desplegamos nuestros contratos. Ingresamos el siguiente comando en la terminal. networks Al hacerlo veremos los contratos desplegados y sus direcciones. Contratos desplegados Luego utilizaremos el comando accounts para asegurarnos que Truffle pudo usar nuestras credenciales. Ingresamos el siguiente comando en la terminal. accounts Y luego veremos las direcciones generadas a partir de nuestras llaves. Direcciones de nuestras cuentas","title":"Comprobando nuestra informaci\u00f3n"},{"location":"exercises/part3/truffle/#contratos","text":"Utilizando Truffle podemos obtener informaci\u00f3n detallada de alguno de los contratos que hemos compilado o desplegado. Experimenta En la terminal de Truffle ingresa esta instrucci\u00f3n let instance = await Concurso.deployed() . Despu\u00e9s escribe instance.address o instance.methods . De esta forma puedes obtener algo de informaci\u00f3n b\u00e1sica del contrato. Si quieres a\u00fan m\u00e1s informaci\u00f3n escribe instance.abi o instance.contract para ver informaci\u00f3n m\u00e1s completa.","title":"Contratos"},{"location":"exercises/part3/truffle/#web3","text":"Web3.js es una librer\u00eda con diversas funcionalidad para la plataforma Ethereum. Experimenta Si deseas conocer cuanto ETH tienes disponible en una cuenta, puedes usar los siguientes comandos. getBalance() obtendr\u00e1 la cantidad disponible expresada en wei y luego fromWei() la transformar\u00e1 a la unidad indicada, ether en este caso. let balance = await web3.eth.getBalance(accounts[0]) let ether = await web3.utils.fromWei(balance, 'ether') ether Para conocer el precio actual del gas, podemos usar el siguiente comando. web3.eth.getGasPrice() El comando getBlock() nos da toda la informaci\u00f3n relevante a un bloque. Al usarlo, cambia el n\u00famero que aparece en el siguiente comando por el n\u00famero del bloque deseado. web3.eth.getBlock(7636163) Finalmente, getTransaction() es otra operaci\u00f3n \u00fatil que nos da informaci\u00f3n sobre una transacci\u00f3n. Cambia el hash que aparece abajo por el hash de la transacci\u00f3n deseada, asegurate de enviar este dato como una cadena de caracteres. web3.eth.getTransaction('0xacdbd478099d729156c6343ca415ac27249ac6f436188dc5c45282913c3ee773') Conoce m\u00e1s Web3 nos ofrece a\u00fan m\u00e1s funcionalidad. Puedes conocerla completa en los siguientes enlaces. web3.eth, funciones principales web3.utils, funciones auxiliares","title":"web3"},{"location":"exercises/part3/truffle/#transacciones","text":"Ahora que ya conocemos la terminal de Truffle realizaremos nuestra primera transacci\u00f3n, la cu\u00e1l ser\u00e1 un dep\u00f3sito hacia el contrato. En la primera instrucci\u00f3n reemplaza 0.01 por la cantidad de ETH que quieras depositar. let ammount = web3.utils.toWei('0.01', 'ether') let result = await instance.deposit({from: accounts[0], value: ammount}) Tip Asegurate de haber obtenido una instancia del contrato antes de ejecutar estos comandos. Asegurate que la cuenta usada ( accounts[0] en nuestro caso) tenga suficientes fondos para depositar. Tras algunos segundos de espera, puedes ingresar result en la terminal para ver la informaci\u00f3n resultante. All\u00ed encontrar\u00e1s un dato llamado transactionHash que puedes buscar en Etherscan para obtener esta misma informaci\u00f3n de una forma quiz\u00e1s m\u00e1s c\u00f3moda. Ahora realizaremos un retiro. ammount = web3.utils.toWei('0.005', 'ether') result = await instance.withdraw(ammount, {from: accounts[0]}) Tip Ya no colocamos let pues ya existen las variables ammount y result . Anteriormente al hacer tests locales comprobamos que solo el creador del contrato (es decir accounts[0] ) puede realizar retiros. Si intentas usar otra cuenta, esta transacci\u00f3n fallar\u00e1. Finalmente podemos consultar la cantidad de ETH restante tras el dep\u00f3sito. let bn = await instance.deposited() let deposited = bn.toNumber() Tip La funci\u00f3n deposited() nos devuelve un objeto BN , es decir un BigNumber, por lo cu\u00e1l debemos convertirlo. Al convertirlo tendremos una cantidad en wei que podr\u00edamos convertir a ether usando la funci\u00f3n fromWei() .","title":"Transacciones"},{"location":"exercises/part4/gas/","text":"Errores por falta de gas \u00b6 El mayor limitante al momento de desplegar contratos sobre Ethereum suele ser el gas. Si colocamos muy pocas unidades de gas al momento de realizar una transacci\u00f3n, esta fallar\u00e1 y perderemos lo pagado. Si pagamos muy poco por cada unidad de gas, nuestra transaccci\u00f3n podr\u00eda demorarse demasiado tiempo. Gas insuficiente \u00b6 Realizaremos una variaci\u00f3n al ejercicio anterior. Estando en la carpeta de nuestro contrato ya desplegado, abrimos la terminal de Truffle. Comenzamos obteniendo una instancia de nuestro contrato y preparando la transacci\u00f3n. let instance = await Concurso.deployed() let ammount = web3.utils.toWei('0.01', 'ether') Luego realizaremos una estimaci\u00f3n del gas a usar. Podemos notar que el siguiente c\u00f3digo es muy similar al usado en el ejercicio anterior, pero ahora agregamos estimateGas() . En mi caso obtengo un resultado de 31745 , este puede variar ligeramente dependiendo del contrato y funci\u00f3n a llamar. await instance.deposit.estimateGas({from: accounts[0], value: ammount}) Ahora intentaremos realizar un dep\u00f3sito, pero especificaremos una cantidad de gas menor a la estimada. let result = await instance.deposit({from: accounts[0], value: ammount, gas: 30000}) Experimenta \u00bfQu\u00e9 resultado obtuvimos? Como la cantidad de gas fue menor a la estimada, mi transacci\u00f3n debi\u00f3 haber fallado. Obtendremos un mensaje de error similar al siguiente (su hash ser\u00e1 distinto). StatusError: Transaction: 0x0123456789abcdef exited with an error (status 0) after consuming all gas. Volveremos a causar un error, pero ahora con una cantidad de gas todav\u00eda m\u00e1s baja. let result = await instance.deposit({from: accounts[0], value: ammount, gas: 5000}) Experimenta Ahora nuestro mensaje de error fue distinto. La cantidad de gas fue tan baja, que la transacci\u00f3n ni siquiera llego a ser enviada. Uncaught { code: -32000, message: 'intrinsic gas too low' } No cambies la cantidad de gas Truffle es capaz de calcular la cantidad correcta de gas a usar. Un error com\u00fan y grave entre nuevos desarrolladores es querer bajar esta cantidad. No cambies la cantidad de gas para evitar este tipo de errores. Precio muy bajo por unidad de gas \u00b6 Ahora reintentaremos la transacci\u00f3n con la cantidad correcta de gas, pero un pago muy bajo por cada unidad. Nuestra transacci\u00f3n tardar\u00e1 mucho tiempo en realizarse, y si bajamos lo suficiente el precio es posible que nunca se ejecute. Primero, usaremos el siguiente comando para conocer el precio actual del gas. Obtendremos un valor en wei, si removemos nueve cifras tendr\u00edamos el valor en gwei. En el testnet Goerli el gas normalmente se encuentra entre 2 y 4 gwei por unidad. web3.eth.getGasPrice() Ahora que conocemos el precio por unidad de gas, intentaremos pagar menos. let result = await instance.deposit({from: accounts[0], value: ammount, gasPrice: 1000}) Experimenta \u00bfQu\u00e9 resultado obtuvimos? Como el precio del gas fue demasiado bajo, recibiremos un mensaje como el siguiente. { code: -32000, message: 'err: max fee per gas less than block base fee: address 0x0123456789abcdef, maxFeePerGas: 1000 baseFee: 2050705937 (supplied gas 15010499)', reason: undefined } Ya que el precio que colocamos fue muy bajo, lo aumentaremos. Revisamos el mensaje de error anterior y usaremos un valor ligeramente mayor al que baseFee que nos indica. En mi caso la transacci\u00f3n queda de esta manera. result = await instance.deposit({from: accounts[0], value: ammount, gasPrice: 2100000000}) Experimenta \u00bfQu\u00e9 sucedi\u00f3 esta vez? Como el precio del gas fue bajo, es posible que nuestra transacci\u00f3n haya tardado m\u00e1s de lo usual en ejecutarse. En Goerli por su bajo uso este efecto no es tan notable, pero puede llegar a ser algo m\u00e1s grave en mainnet.","title":"Errores por falta de gas"},{"location":"exercises/part4/gas/#errores-por-falta-de-gas","text":"El mayor limitante al momento de desplegar contratos sobre Ethereum suele ser el gas. Si colocamos muy pocas unidades de gas al momento de realizar una transacci\u00f3n, esta fallar\u00e1 y perderemos lo pagado. Si pagamos muy poco por cada unidad de gas, nuestra transaccci\u00f3n podr\u00eda demorarse demasiado tiempo.","title":"Errores por falta de gas"},{"location":"exercises/part4/gas/#gas-insuficiente","text":"Realizaremos una variaci\u00f3n al ejercicio anterior. Estando en la carpeta de nuestro contrato ya desplegado, abrimos la terminal de Truffle. Comenzamos obteniendo una instancia de nuestro contrato y preparando la transacci\u00f3n. let instance = await Concurso.deployed() let ammount = web3.utils.toWei('0.01', 'ether') Luego realizaremos una estimaci\u00f3n del gas a usar. Podemos notar que el siguiente c\u00f3digo es muy similar al usado en el ejercicio anterior, pero ahora agregamos estimateGas() . En mi caso obtengo un resultado de 31745 , este puede variar ligeramente dependiendo del contrato y funci\u00f3n a llamar. await instance.deposit.estimateGas({from: accounts[0], value: ammount}) Ahora intentaremos realizar un dep\u00f3sito, pero especificaremos una cantidad de gas menor a la estimada. let result = await instance.deposit({from: accounts[0], value: ammount, gas: 30000}) Experimenta \u00bfQu\u00e9 resultado obtuvimos? Como la cantidad de gas fue menor a la estimada, mi transacci\u00f3n debi\u00f3 haber fallado. Obtendremos un mensaje de error similar al siguiente (su hash ser\u00e1 distinto). StatusError: Transaction: 0x0123456789abcdef exited with an error (status 0) after consuming all gas. Volveremos a causar un error, pero ahora con una cantidad de gas todav\u00eda m\u00e1s baja. let result = await instance.deposit({from: accounts[0], value: ammount, gas: 5000}) Experimenta Ahora nuestro mensaje de error fue distinto. La cantidad de gas fue tan baja, que la transacci\u00f3n ni siquiera llego a ser enviada. Uncaught { code: -32000, message: 'intrinsic gas too low' } No cambies la cantidad de gas Truffle es capaz de calcular la cantidad correcta de gas a usar. Un error com\u00fan y grave entre nuevos desarrolladores es querer bajar esta cantidad. No cambies la cantidad de gas para evitar este tipo de errores.","title":"Gas insuficiente"},{"location":"exercises/part4/gas/#precio-muy-bajo-por-unidad-de-gas","text":"Ahora reintentaremos la transacci\u00f3n con la cantidad correcta de gas, pero un pago muy bajo por cada unidad. Nuestra transacci\u00f3n tardar\u00e1 mucho tiempo en realizarse, y si bajamos lo suficiente el precio es posible que nunca se ejecute. Primero, usaremos el siguiente comando para conocer el precio actual del gas. Obtendremos un valor en wei, si removemos nueve cifras tendr\u00edamos el valor en gwei. En el testnet Goerli el gas normalmente se encuentra entre 2 y 4 gwei por unidad. web3.eth.getGasPrice() Ahora que conocemos el precio por unidad de gas, intentaremos pagar menos. let result = await instance.deposit({from: accounts[0], value: ammount, gasPrice: 1000}) Experimenta \u00bfQu\u00e9 resultado obtuvimos? Como el precio del gas fue demasiado bajo, recibiremos un mensaje como el siguiente. { code: -32000, message: 'err: max fee per gas less than block base fee: address 0x0123456789abcdef, maxFeePerGas: 1000 baseFee: 2050705937 (supplied gas 15010499)', reason: undefined } Ya que el precio que colocamos fue muy bajo, lo aumentaremos. Revisamos el mensaje de error anterior y usaremos un valor ligeramente mayor al que baseFee que nos indica. En mi caso la transacci\u00f3n queda de esta manera. result = await instance.deposit({from: accounts[0], value: ammount, gasPrice: 2100000000}) Experimenta \u00bfQu\u00e9 sucedi\u00f3 esta vez? Como el precio del gas fue bajo, es posible que nuestra transacci\u00f3n haya tardado m\u00e1s de lo usual en ejecutarse. En Goerli por su bajo uso este efecto no es tan notable, pero puede llegar a ser algo m\u00e1s grave en mainnet.","title":"Precio muy bajo por unidad de gas"},{"location":"exercises/part4/interaction/","text":"Interactuando con contratos fuera de la terminal \u00b6 Hasta este punto hemos realizado las llamadas a contratos desde nuestra terminal, pero tambi\u00e9n podemos realizarlas desde alg\u00fan programa independiente, siempre gracias a Truffle. Creando un programa que interactue con nuestro contrato \u00b6 En la ra\u00edz de nuestra carpeta desde la cual desplegamos nuestros contratos crearemos un nuevo archivo de Javascript. /* interaction.js */ // Obtener instancia del contrato desplegado // Necesitamos una l\u00ednea adicional respecto a lo que hac\u00edamos en la terminal const contract = artifacts.require(\"Log\"); // Truffle necesita que nuestras funciones vayan dentro de este module.exports module.exports = function() { // Leemos todos los logs del contrato async function readLogs() { let instance = await contract.deployed(); instance.getPastEvents( \"LogScore\", {fromBlock: 0} ).then( async (logs) => { // funci\u00f3n as\u00edncrona para poder usar await dentro for (const elem of logs) { // usamos for en lugar de forEach para poder usar await dentro console.log(\"Score: \" + elem.args._score.toNumber()); let blockNumber = elem.blockNumber; let block = await web3.eth.getBlock(blockNumber); // podemos usar la librer\u00eda web3 console.log(\"Timestamp: \" + block.timestamp); let date = new Date(block.timestamp * 1000) // milisegundos a segundos console.log(\"Date: \" + date); } } ); } // Podemos definir todas las funciones que querramos en esta parte // Llamamos a alguna de nuestras funciones readLogs(); } Para ejecutar este archivo usamos el siguiente comando desde la terminal normal (es decir, no desde la terminal de Truffle). truffle exec --network goerli interaction.js De esta manera podemos crear programas mucho m\u00e1s complejos que aprovechen la interacci\u00f3n con nuestros contratos.","title":"Leer y escribir hacia contrato"},{"location":"exercises/part4/interaction/#interactuando-con-contratos-fuera-de-la-terminal","text":"Hasta este punto hemos realizado las llamadas a contratos desde nuestra terminal, pero tambi\u00e9n podemos realizarlas desde alg\u00fan programa independiente, siempre gracias a Truffle.","title":"Interactuando con contratos fuera de la terminal"},{"location":"exercises/part4/interaction/#creando-un-programa-que-interactue-con-nuestro-contrato","text":"En la ra\u00edz de nuestra carpeta desde la cual desplegamos nuestros contratos crearemos un nuevo archivo de Javascript. /* interaction.js */ // Obtener instancia del contrato desplegado // Necesitamos una l\u00ednea adicional respecto a lo que hac\u00edamos en la terminal const contract = artifacts.require(\"Log\"); // Truffle necesita que nuestras funciones vayan dentro de este module.exports module.exports = function() { // Leemos todos los logs del contrato async function readLogs() { let instance = await contract.deployed(); instance.getPastEvents( \"LogScore\", {fromBlock: 0} ).then( async (logs) => { // funci\u00f3n as\u00edncrona para poder usar await dentro for (const elem of logs) { // usamos for en lugar de forEach para poder usar await dentro console.log(\"Score: \" + elem.args._score.toNumber()); let blockNumber = elem.blockNumber; let block = await web3.eth.getBlock(blockNumber); // podemos usar la librer\u00eda web3 console.log(\"Timestamp: \" + block.timestamp); let date = new Date(block.timestamp * 1000) // milisegundos a segundos console.log(\"Date: \" + date); } } ); } // Podemos definir todas las funciones que querramos en esta parte // Llamamos a alguna de nuestras funciones readLogs(); } Para ejecutar este archivo usamos el siguiente comando desde la terminal normal (es decir, no desde la terminal de Truffle). truffle exec --network goerli interaction.js De esta manera podemos crear programas mucho m\u00e1s complejos que aprovechen la interacci\u00f3n con nuestros contratos.","title":"Creando un programa que interactue con nuestro contrato"},{"location":"exercises/part4/log/","text":"Utilizando los logs como almacenamiento barato \u00b6 Crear variables para almacenar datos puede resultar costoso, por lo tanto puede ser conveniente utilizar logs para guardar nuestra informaci\u00f3n. Comparando costos en despliegue de contrato \u00b6 Iniciamos un nuevo proyecto, nos aseguramos de instalar las librer\u00edas necesarias en esta carpeta, y crearemos varios contratos. mkdir storage cd storage truffle init npm install dotenv npm install @truffle/hdwallet-provider truffle create contract Storage truffle create contract Log truffle create contract Migrations Dentro de los contratos en la carpeta contracts colocaremos el siguiente c\u00f3digo. /* Storage */ // SPDX-License-Identifier: MIT pragma solidity >=0.4.22 <0.9.0; contract Storage { address private owner; int public score; constructor() public { owner = msg.sender; } function reportScore (int _score) public { require(msg.sender == owner, \"Only the owner is authorized to report events\"); score = _score; } } /* Log */ // SPDX-License-Identifier: MIT pragma solidity >=0.4.22 <0.9.0; contract Log { address private owner; constructor() public { owner = msg.sender; } event LogScore(address _sender, int indexed _score); function reportScore (int _score) public { require(msg.sender == owner, \"Only the owner is authorized to report events\"); emit LogScore(msg.sender, _score); } } /* Migrations */ // SPDX-License-Identifier: MIT pragma solidity >=0.4.22 <0.9.0; contract Migrations { address public owner = msg.sender; uint public last_completed_migration; modifier restricted() { require( msg.sender == owner, \"This function is restricted to the contract's owner\" ); _; } function setCompleted(uint completed) public restricted { last_completed_migration = completed; } } Adicionalmente debemos crear dos archivos con el siguiente c\u00f3digo en la carpeta migrations . // 1_initial_migrations.js const Migrations = artifacts.require(\"Migrations\"); module.exports = function (deployer) { deployer.deploy(Migrations); }; // 2_deploy_contracts.js const Storage = artifacts.require(\"Storage\"); const Log = artifacts.require(\"Log\"); module.exports = function(deployer) { deployer.deploy(Storage); deployer.deploy(Log); }; Para finalizar, colocamos nuestra llave dentro del archivo .env y modificamos el archivo truffle-config.js como realizamos en ejercicios anteriores. Tras preparar todo esto, estamos listos para realizar la migraci\u00f3n. truffle migrate --network goerli Compara Desplegar Storage tuvo un costo de 213661 unidades de gas. Desplegar Log debi\u00f3 costar 224881 unidades de gas. De momento parece que Storage es m\u00e1s barato, pero esto cambiar\u00e1 cuando empecemos a realizar transacciones. Comparando costos en transacciones \u00b6 Ahora usaremos la terminal de Truffle para realizar una transacci\u00f3n para almacenar informaci\u00f3n en cada contrato. Iniciaremos con Storage . let storage = await Storage.deployed() let storageResult = await storage.reportScore(12345) storageResult.receipt.gasUsed Luego almacenaremos informaci\u00f3n en Log . Aunque ahora estamos usando log en lugar de variables, la llamada al contrato se ve igual. let log = await Log.deployed() let logResult = await log.reportScore(12345) logResult.receipt.gasUsed Compara Almacenar en la variable de Storage tuvo un costo de 45881 unidades de gas. Generar un log en Log tuvo un costo significativamente m\u00e1s bajo de solo 25384 unidades de gas. A pesar que desplegar Log fue ligeramente m\u00e1s costoso, sus operaciones siguientes son mucho m\u00e1s baratas. Accediendo a la informaci\u00f3n guardada en un log \u00b6 Leer una variables es bastante sencillo, como vimos en ejercicios anteriores. Usamos el siguiente c\u00f3digo para leer y transformar a n\u00famero el BigNumber le\u00eddo. let bn = await storage.score() bn.toNumber() La lectura de logs se realiza de forma diferente. Primero obtenemos un arreglo que contiene todos los logs con el siguiente c\u00f3digo. Si quisieramos obtener solo los m\u00e1s recientes, podemos indicar alg\u00fan bloque en espec\u00edfico con fromBlock: 0 . let logs = await log.getPastEvents(\"LogScore\", {fromBlock: 0}) Luego tenemos varias formas de visualizar el valor que guardamos. Las siguientes dos l\u00edneas permiten obtenerlo como hexadecimal o como decimal respectivamente. logs[0].raw.topics[1] logs[0].args._score.toNumber() Adicionalmente, tambi\u00e9n podemos obtener informaci\u00f3n de cu\u00e1ndo se realiz\u00f3 el almacenamiento si usamos este c\u00f3digo. Debemos recordar que las transacciones no se realizan de forma inmediata, sino que se ejecutan cuando son aceptadas como parte de un bloque. Aqu\u00ed obtendremos el timestamp del bloque en formato Unix. let blockNumber = logs[0].blockNumber let block = await web3.eth.getBlock(blockNumber) block.timestamp En conclusi\u00f3n, los logs pueden usarse como una forma de almacenamiento m\u00e1s poderosa y m\u00e1s barata que las variables.","title":"Logs como almacenamiento barato"},{"location":"exercises/part4/log/#utilizando-los-logs-como-almacenamiento-barato","text":"Crear variables para almacenar datos puede resultar costoso, por lo tanto puede ser conveniente utilizar logs para guardar nuestra informaci\u00f3n.","title":"Utilizando los logs como almacenamiento barato"},{"location":"exercises/part4/log/#comparando-costos-en-despliegue-de-contrato","text":"Iniciamos un nuevo proyecto, nos aseguramos de instalar las librer\u00edas necesarias en esta carpeta, y crearemos varios contratos. mkdir storage cd storage truffle init npm install dotenv npm install @truffle/hdwallet-provider truffle create contract Storage truffle create contract Log truffle create contract Migrations Dentro de los contratos en la carpeta contracts colocaremos el siguiente c\u00f3digo. /* Storage */ // SPDX-License-Identifier: MIT pragma solidity >=0.4.22 <0.9.0; contract Storage { address private owner; int public score; constructor() public { owner = msg.sender; } function reportScore (int _score) public { require(msg.sender == owner, \"Only the owner is authorized to report events\"); score = _score; } } /* Log */ // SPDX-License-Identifier: MIT pragma solidity >=0.4.22 <0.9.0; contract Log { address private owner; constructor() public { owner = msg.sender; } event LogScore(address _sender, int indexed _score); function reportScore (int _score) public { require(msg.sender == owner, \"Only the owner is authorized to report events\"); emit LogScore(msg.sender, _score); } } /* Migrations */ // SPDX-License-Identifier: MIT pragma solidity >=0.4.22 <0.9.0; contract Migrations { address public owner = msg.sender; uint public last_completed_migration; modifier restricted() { require( msg.sender == owner, \"This function is restricted to the contract's owner\" ); _; } function setCompleted(uint completed) public restricted { last_completed_migration = completed; } } Adicionalmente debemos crear dos archivos con el siguiente c\u00f3digo en la carpeta migrations . // 1_initial_migrations.js const Migrations = artifacts.require(\"Migrations\"); module.exports = function (deployer) { deployer.deploy(Migrations); }; // 2_deploy_contracts.js const Storage = artifacts.require(\"Storage\"); const Log = artifacts.require(\"Log\"); module.exports = function(deployer) { deployer.deploy(Storage); deployer.deploy(Log); }; Para finalizar, colocamos nuestra llave dentro del archivo .env y modificamos el archivo truffle-config.js como realizamos en ejercicios anteriores. Tras preparar todo esto, estamos listos para realizar la migraci\u00f3n. truffle migrate --network goerli Compara Desplegar Storage tuvo un costo de 213661 unidades de gas. Desplegar Log debi\u00f3 costar 224881 unidades de gas. De momento parece que Storage es m\u00e1s barato, pero esto cambiar\u00e1 cuando empecemos a realizar transacciones.","title":"Comparando costos en despliegue de contrato"},{"location":"exercises/part4/log/#comparando-costos-en-transacciones","text":"Ahora usaremos la terminal de Truffle para realizar una transacci\u00f3n para almacenar informaci\u00f3n en cada contrato. Iniciaremos con Storage . let storage = await Storage.deployed() let storageResult = await storage.reportScore(12345) storageResult.receipt.gasUsed Luego almacenaremos informaci\u00f3n en Log . Aunque ahora estamos usando log en lugar de variables, la llamada al contrato se ve igual. let log = await Log.deployed() let logResult = await log.reportScore(12345) logResult.receipt.gasUsed Compara Almacenar en la variable de Storage tuvo un costo de 45881 unidades de gas. Generar un log en Log tuvo un costo significativamente m\u00e1s bajo de solo 25384 unidades de gas. A pesar que desplegar Log fue ligeramente m\u00e1s costoso, sus operaciones siguientes son mucho m\u00e1s baratas.","title":"Comparando costos en transacciones"},{"location":"exercises/part4/log/#accediendo-a-la-informacion-guardada-en-un-log","text":"Leer una variables es bastante sencillo, como vimos en ejercicios anteriores. Usamos el siguiente c\u00f3digo para leer y transformar a n\u00famero el BigNumber le\u00eddo. let bn = await storage.score() bn.toNumber() La lectura de logs se realiza de forma diferente. Primero obtenemos un arreglo que contiene todos los logs con el siguiente c\u00f3digo. Si quisieramos obtener solo los m\u00e1s recientes, podemos indicar alg\u00fan bloque en espec\u00edfico con fromBlock: 0 . let logs = await log.getPastEvents(\"LogScore\", {fromBlock: 0}) Luego tenemos varias formas de visualizar el valor que guardamos. Las siguientes dos l\u00edneas permiten obtenerlo como hexadecimal o como decimal respectivamente. logs[0].raw.topics[1] logs[0].args._score.toNumber() Adicionalmente, tambi\u00e9n podemos obtener informaci\u00f3n de cu\u00e1ndo se realiz\u00f3 el almacenamiento si usamos este c\u00f3digo. Debemos recordar que las transacciones no se realizan de forma inmediata, sino que se ejecutan cuando son aceptadas como parte de un bloque. Aqu\u00ed obtendremos el timestamp del bloque en formato Unix. let blockNumber = logs[0].blockNumber let block = await web3.eth.getBlock(blockNumber) block.timestamp En conclusi\u00f3n, los logs pueden usarse como una forma de almacenamiento m\u00e1s poderosa y m\u00e1s barata que las variables.","title":"Accediendo a la informaci\u00f3n guardada en un log"},{"location":"exercises/part4/web3/","text":"Web3 para interactuar con un contrato \u00b6 Es momento de aprovechar Webpack para interactuar con un contrato propio. Desplegaremos un contrato y modificaremos index.js , el archivo creado por Webpack para poder comunicarnos con nuestro contrato. Desplegando un contrato \u00b6 Caso de uso Necesitamos publicar un mensaje que no pueda ser modificado o eliminado. Desafortunadamente una publicaci\u00edon en redes sociales o en un sitio privado no funciona para esto. Escribiremos nuestro mensaje en el blockchain para que sea realmente permanente. Escribiremos el mensaje como log para ahorrar un poco de gas. La forma m\u00e1s f\u00e1cil de crear un sitio para interactuar con un contrato es usando el box de Webpack que Truffle nos provee. mkdir message cd message truffle unbox webpack Recuerda instalar las herramientas en la nueva carpeta. npm install dotenv npm install @truffle/hdwallet-provider Recuerda tambi\u00e9n copiar tus llaves y configuraci\u00f3n que has usado en ejercicios anteriores, copia .env y truffle-config.js hacia la carpeta actual. Al igual que en el ejercicio anterior, debemos realizar un cambio en el archivo contracts/Migrations.sol . Ve al contrato y cambia la versi\u00f3n que aparece al inicio. pragma solidity >=0.4.21 <=0.8.16; Puedes eliminar los archivos contracts/MetaCoin.sol y contracts/ConvertLib.sol . Luego crearemos el contrato Message.sol con el siguiente contenido. Es un contrato sencillo que nos permitir\u00e1 escribir un mensaje hacia el log. // SPDX-License-Identifier: MIT pragma solidity >=0.4.21 <=0.8.16; contract Message { constructor() public { } event LogMessage(address _sender, string _msg); function submitMessage (string memory _msg) public { emit LogMessage(msg.sender, _msg); } } Finalmente, modificaremos el archivo migrations/2_deploy_contracts . MetaCoin y ConvertLib ya no existen, entonces ahora nuestro archivo debe quedar de esta manera. const Message = artifacts.require(\"Message\"); module.exports = function(deployer) { deployer.deploy(Message); }; \u00a1Listo! Estamos preparados para desplegar como lo hemos realizado ya un par de veces. truffle migrate --network goerli Una vez desplegado nuestro contrato, podr\u00edamos probarlo manualmente desde la consola de Truffle. let instance = Message.deployed() let result = instance.submitMessage(\"Hola mundo!\", {from: accounts[0]}) Despu\u00e9s busca tu transacci\u00f3n en Etherscan, y en la pesta\u00f1a de Logs podr\u00e1s ver la siguiente informaci\u00f3n. El valor en hexadecimal corresponde a la direcci\u00f3n que realiz\u00f3 la transacci\u00f3n, y el n\u00famero en decimal corresponde a la longitud del mensaje. Direcci\u00f3n, longitud y mensaje en el Etherscan Creando nuestro sitio \u00b6 Modificaremos el sitio que el box de Webpack cre\u00f3. Ve al archivo app/src/index.html y reemplaza el contenido por lo siguiente. <!DOCTYPE html> <html> <head> <title>Submit a message!</title> </head> <body> <h1>Submit a message!</h1> <label for=\"message\">Message:</label> <input type=\"text\" id=\"message\" placeholder=\"Say something!\" /> <button onclick=\"App.submitMessage()\">Submit!</button> <p id=\"status\"></p> <script src=\"index.js\"></script> </body> </html> Interfaz que pronto interactuar\u00e1 con nuestro contrato Modificando index.js para interactuar con nuestro contrato \u00b6 Vamos a modificar app/src/index.js . Este archivo es sumamente importante, pues adem\u00e1s de incluir nuestro c\u00f3digo le indica a Webpack que otros archivos debe empaquetar al momento de generar nuestra aplicaci\u00f3n. Para comenzar, ahora importaremos Message.json en lugar de MetaCoin.json . Al inicio del archivo, cambia para colocar lo siguiente. import messageArtifact from \"../../build/contracts/Message.json\"; Despu\u00e9s debemos sustituir las referencias a metacoinArtifact por messageArtifact . Dentro de la funci\u00f3n start busca la variable deployedNetwork y realiza las siguientes modificaciones. const deployedNetwork = messageArtifact.networks[networkId]; this.meta = new web3.eth.Contract( messageArtifact.abi, deployedNetwork.address, ); M\u00e1s abajo, todav\u00eda dentro de start elimina this.refreshBalance(); pues tambi\u00e9n eliminaremos esa funci\u00f3n. Elimina por completo las funciones refreshBalance y sendCoin pues estas eran espec\u00edficas para Metacoin . Nosotros crearemos la siguiente funci\u00f3n que interactua con nuestro contrato Message . submitMessage: async function () { const message = document.getElementById(\"message\").value; this.setStatus(\"Submiting message...\"); // La llamada se realiza de forma ligeramente distinta // a como la realizamos desde la consola de Truffle const { submitMessage } = this.meta.methods; await submitMessage(message).send({ from: this.account }); this.setStatus(\"Success!\"); }, Asegurate de colocar una coma al final para separarlo de setStatus . setStatus no sufre ning\u00fan cambio Al completar estos cambios, index.js se ver\u00e1 de esta manera. import Web3 from \"web3\"; import messageArtifact from \"../../build/contracts/Message.json\"; const App = { web3: null, account: null, meta: null, start: async function() { const { web3 } = this; try { // get contract instance const networkId = await web3.eth.net.getId(); const deployedNetwork = messageArtifact.networks[networkId]; this.meta = new web3.eth.Contract( messageArtifact.abi, deployedNetwork.address, ); // get accounts const accounts = await web3.eth.getAccounts(); this.account = accounts[0]; } catch (error) { console.error(\"Could not connect to contract or chain.\"); } }, submitMessage: async function () { const message = document.getElementById(\"message\").value; this.setStatus(\"Submiting message...\"); const { submitMessage } = this.meta.methods; await submitMessage(message).send({ from: this.account }); this.setStatus(\"Success!\"); }, setStatus: function(message) { const status = document.getElementById(\"status\"); status.innerHTML = message; }, }; window.App = App; window.addEventListener(\"load\", function() { if (window.ethereum) { // use MetaMask's provider App.web3 = new Web3(window.ethereum); window.ethereum.enable(); // get permission to access accounts } else { console.warn( \"No web3 detected. Falling back to http://127.0.0.1:8545. You should remove this fallback when you deploy live\", ); // fallback - use your fallback strategy (local node / hosted node + in-dapp id mgmt / fail) App.web3 = new Web3( new Web3.providers.HttpProvider(\"http://127.0.0.1:8545\"), ); } App.start(); }); Probando nuestra aplicaci\u00f3n \u00b6 Iniciamos el servidor de pruebas ejecutando el siguiente comando desde la carpeta app . npm run dev Al visitar el sitio desde nuestro navegador, Metamask nos preguntar\u00e1 si deseamos conectarnos. Despu\u00e9s de conectarnos exitosamente, por lo general se necesita refrescar la p\u00e1gina para que funcione correctamente. Tras recargar, podemos escribir un mensaje y presionar el bot\u00f3n para enviarlo. Abajo aparecer\u00e1 un mensaje y se abrir\u00e1 una ventana de Metamask para que autoricemos la transacci\u00f3n. Metamask nos pide autorizaci\u00f3n para realizar la transacci\u00f3n Nuestra transacci\u00f3n est\u00e1 siendo procesada Esperamos algunos segundos y despu\u00e9s Metamask nos indicar\u00e1 que la transacci\u00f3n fue exitosa, podemos hacer click en ese mensaje para verla en Etherscan. Cuando esto suceda, el mensaje en la p\u00e1gina cambiar\u00e1. Notificaci\u00f3n de Metamask indicando una transacci\u00f3n exitosa Mensaje en nuestra interfaz indicando que la transacci\u00f3n se complet\u00f3","title":"Web3 para interactuar con contrato"},{"location":"exercises/part4/web3/#web3-para-interactuar-con-un-contrato","text":"Es momento de aprovechar Webpack para interactuar con un contrato propio. Desplegaremos un contrato y modificaremos index.js , el archivo creado por Webpack para poder comunicarnos con nuestro contrato.","title":"Web3 para interactuar con un contrato"},{"location":"exercises/part4/web3/#desplegando-un-contrato","text":"Caso de uso Necesitamos publicar un mensaje que no pueda ser modificado o eliminado. Desafortunadamente una publicaci\u00edon en redes sociales o en un sitio privado no funciona para esto. Escribiremos nuestro mensaje en el blockchain para que sea realmente permanente. Escribiremos el mensaje como log para ahorrar un poco de gas. La forma m\u00e1s f\u00e1cil de crear un sitio para interactuar con un contrato es usando el box de Webpack que Truffle nos provee. mkdir message cd message truffle unbox webpack Recuerda instalar las herramientas en la nueva carpeta. npm install dotenv npm install @truffle/hdwallet-provider Recuerda tambi\u00e9n copiar tus llaves y configuraci\u00f3n que has usado en ejercicios anteriores, copia .env y truffle-config.js hacia la carpeta actual. Al igual que en el ejercicio anterior, debemos realizar un cambio en el archivo contracts/Migrations.sol . Ve al contrato y cambia la versi\u00f3n que aparece al inicio. pragma solidity >=0.4.21 <=0.8.16; Puedes eliminar los archivos contracts/MetaCoin.sol y contracts/ConvertLib.sol . Luego crearemos el contrato Message.sol con el siguiente contenido. Es un contrato sencillo que nos permitir\u00e1 escribir un mensaje hacia el log. // SPDX-License-Identifier: MIT pragma solidity >=0.4.21 <=0.8.16; contract Message { constructor() public { } event LogMessage(address _sender, string _msg); function submitMessage (string memory _msg) public { emit LogMessage(msg.sender, _msg); } } Finalmente, modificaremos el archivo migrations/2_deploy_contracts . MetaCoin y ConvertLib ya no existen, entonces ahora nuestro archivo debe quedar de esta manera. const Message = artifacts.require(\"Message\"); module.exports = function(deployer) { deployer.deploy(Message); }; \u00a1Listo! Estamos preparados para desplegar como lo hemos realizado ya un par de veces. truffle migrate --network goerli Una vez desplegado nuestro contrato, podr\u00edamos probarlo manualmente desde la consola de Truffle. let instance = Message.deployed() let result = instance.submitMessage(\"Hola mundo!\", {from: accounts[0]}) Despu\u00e9s busca tu transacci\u00f3n en Etherscan, y en la pesta\u00f1a de Logs podr\u00e1s ver la siguiente informaci\u00f3n. El valor en hexadecimal corresponde a la direcci\u00f3n que realiz\u00f3 la transacci\u00f3n, y el n\u00famero en decimal corresponde a la longitud del mensaje. Direcci\u00f3n, longitud y mensaje en el Etherscan","title":"Desplegando un contrato"},{"location":"exercises/part4/web3/#creando-nuestro-sitio","text":"Modificaremos el sitio que el box de Webpack cre\u00f3. Ve al archivo app/src/index.html y reemplaza el contenido por lo siguiente. <!DOCTYPE html> <html> <head> <title>Submit a message!</title> </head> <body> <h1>Submit a message!</h1> <label for=\"message\">Message:</label> <input type=\"text\" id=\"message\" placeholder=\"Say something!\" /> <button onclick=\"App.submitMessage()\">Submit!</button> <p id=\"status\"></p> <script src=\"index.js\"></script> </body> </html> Interfaz que pronto interactuar\u00e1 con nuestro contrato","title":"Creando nuestro sitio"},{"location":"exercises/part4/web3/#modificando-indexjs-para-interactuar-con-nuestro-contrato","text":"Vamos a modificar app/src/index.js . Este archivo es sumamente importante, pues adem\u00e1s de incluir nuestro c\u00f3digo le indica a Webpack que otros archivos debe empaquetar al momento de generar nuestra aplicaci\u00f3n. Para comenzar, ahora importaremos Message.json en lugar de MetaCoin.json . Al inicio del archivo, cambia para colocar lo siguiente. import messageArtifact from \"../../build/contracts/Message.json\"; Despu\u00e9s debemos sustituir las referencias a metacoinArtifact por messageArtifact . Dentro de la funci\u00f3n start busca la variable deployedNetwork y realiza las siguientes modificaciones. const deployedNetwork = messageArtifact.networks[networkId]; this.meta = new web3.eth.Contract( messageArtifact.abi, deployedNetwork.address, ); M\u00e1s abajo, todav\u00eda dentro de start elimina this.refreshBalance(); pues tambi\u00e9n eliminaremos esa funci\u00f3n. Elimina por completo las funciones refreshBalance y sendCoin pues estas eran espec\u00edficas para Metacoin . Nosotros crearemos la siguiente funci\u00f3n que interactua con nuestro contrato Message . submitMessage: async function () { const message = document.getElementById(\"message\").value; this.setStatus(\"Submiting message...\"); // La llamada se realiza de forma ligeramente distinta // a como la realizamos desde la consola de Truffle const { submitMessage } = this.meta.methods; await submitMessage(message).send({ from: this.account }); this.setStatus(\"Success!\"); }, Asegurate de colocar una coma al final para separarlo de setStatus . setStatus no sufre ning\u00fan cambio Al completar estos cambios, index.js se ver\u00e1 de esta manera. import Web3 from \"web3\"; import messageArtifact from \"../../build/contracts/Message.json\"; const App = { web3: null, account: null, meta: null, start: async function() { const { web3 } = this; try { // get contract instance const networkId = await web3.eth.net.getId(); const deployedNetwork = messageArtifact.networks[networkId]; this.meta = new web3.eth.Contract( messageArtifact.abi, deployedNetwork.address, ); // get accounts const accounts = await web3.eth.getAccounts(); this.account = accounts[0]; } catch (error) { console.error(\"Could not connect to contract or chain.\"); } }, submitMessage: async function () { const message = document.getElementById(\"message\").value; this.setStatus(\"Submiting message...\"); const { submitMessage } = this.meta.methods; await submitMessage(message).send({ from: this.account }); this.setStatus(\"Success!\"); }, setStatus: function(message) { const status = document.getElementById(\"status\"); status.innerHTML = message; }, }; window.App = App; window.addEventListener(\"load\", function() { if (window.ethereum) { // use MetaMask's provider App.web3 = new Web3(window.ethereum); window.ethereum.enable(); // get permission to access accounts } else { console.warn( \"No web3 detected. Falling back to http://127.0.0.1:8545. You should remove this fallback when you deploy live\", ); // fallback - use your fallback strategy (local node / hosted node + in-dapp id mgmt / fail) App.web3 = new Web3( new Web3.providers.HttpProvider(\"http://127.0.0.1:8545\"), ); } App.start(); });","title":"Modificando index.js para interactuar con nuestro contrato"},{"location":"exercises/part4/web3/#probando-nuestra-aplicacion","text":"Iniciamos el servidor de pruebas ejecutando el siguiente comando desde la carpeta app . npm run dev Al visitar el sitio desde nuestro navegador, Metamask nos preguntar\u00e1 si deseamos conectarnos. Despu\u00e9s de conectarnos exitosamente, por lo general se necesita refrescar la p\u00e1gina para que funcione correctamente. Tras recargar, podemos escribir un mensaje y presionar el bot\u00f3n para enviarlo. Abajo aparecer\u00e1 un mensaje y se abrir\u00e1 una ventana de Metamask para que autoricemos la transacci\u00f3n. Metamask nos pide autorizaci\u00f3n para realizar la transacci\u00f3n Nuestra transacci\u00f3n est\u00e1 siendo procesada Esperamos algunos segundos y despu\u00e9s Metamask nos indicar\u00e1 que la transacci\u00f3n fue exitosa, podemos hacer click en ese mensaje para verla en Etherscan. Cuando esto suceda, el mensaje en la p\u00e1gina cambiar\u00e1. Notificaci\u00f3n de Metamask indicando una transacci\u00f3n exitosa Mensaje en nuestra interfaz indicando que la transacci\u00f3n se complet\u00f3","title":"Probando nuestra aplicaci\u00f3n"},{"location":"exercises/part4/webpack/","text":"Utilizando Webpack \u00b6 Webpack es una herramienta que nos permite tomar m\u00faltiples librer\u00edas y dependencias y empaquetarlas de forma que sea f\u00e1cil incluirlas en una p\u00e1gina web. Webpack es la herramienta recomendada por Truffle para incluir Web3 e interacciones con contratos en nuestros sitios. Preparando el entorno de trabajo \u00b6 Truffle nos provee paquetes ejemplo listos para usarse. Para usar Webpack nos provee un paquete que incluye contratos, migraciones, tests, interfaz de usuario y scripts para generar nuestro sitio. Podemos seguir las instrucciones en el tutorial de Truffle + Webpack , o las instrucciones siguientes. Como ya tenemos Truffle instalado, creamos un directorio nuevo y all\u00ed desempaquetamos el ejemplo de Webpack. mkdir webpack-demo cd webpack-demo truffle unbox webpack Esto descargar\u00e1 el ejemplo y colocar\u00e1 en las carpetas respectivas todos los archivos. Debemos abrir cada uno de los contratos, y al inicio debemos realizar un peque\u00f1o cambio. Reemplazamos <0.7.0 por <=0.8.16 para usar la versi\u00f3n del compilador de Solidity que tenemos instalada. pragma solidity >=0.4.21 <=0.8.16; Para poder continuar, debemos desplegar los contratos que modificamos. Estos contratos representan MetaCoin, el cual es un tokene sencillo. Recordamos que para poder desplegar debemos colocar nuestra llave en el archivo .env as\u00ed como realizar las configuraciones necesarias en truffle-config.js . Tambi\u00e9n si no los instalamos de forma global, instalaremos dotenv y hdwallet-provider en la carpeta actual. npm install dotenv npm install @truffle/hdwallet-provider Despu\u00e9s de esta instalaci\u00f3n podemos desplegar con el siguiente comando. truffle migrate --network goerli Ejecutando la aplicaci\u00f3n web \u00b6 Con nuestro contrato desplegado, vamos a la carpeta app y desde all\u00ed iniciamos un servidor de pruebas. cd app npm run dev Podremos ver algunos mensajes en nuestra terminal que nos indican que un servidor est\u00e1 ejecut\u00e1ndose en http://localhost:8000/ y que Webpack fue el encargado de preparar todas las librer\u00edas necesarias para su funcionamiento. Abrimos esta p\u00e1gina en nuestro navegador y al hacerlo notaremos que se abrir\u00e1 una ventana de Metamask. Tras ingresar a Metamask, se nos preguntar\u00e1 si queremos permitir que el sitio se conecte con nuestra billetera, aceptamos esto haciendo click en Next y luego en Connect . Metamask nos pregunta si deseamos dar acceso a nuestra cuenta Luego de esto la aplicaci\u00f3n ejemplo est\u00e1 lista para usarse, solo debemos recargar la p\u00e1gina. Tras recargar, veremos que tenemos disponible 10000 META , es decir de nuestro token de prueba. Aplicaci\u00f3n web ejecut\u00e1ndose en nuestro navegador Podemos usar esta interfaz para realizar transferencias del token hacia otras direcciones. Funcionamiento de Webpack \u00b6 Cuando usamos el comando npm run dev se ejecuta webpack-dev-server el cual es el encargado de iniciar un servidor para pruebas. Webpack utiliza el archivo webpack.config.js para saber cu\u00e1l es su punto de inicio, es decir, cu\u00e1l es el script principal de nuestra aplicaci\u00f3n web. Podemos explorar el archivo index.js el cual es el punto de inicio. Detalles de index.js \u00b6 Al inicio de este archivo encontramos que se importan dos elementos, la librer\u00eda Web3 y un JSON que representa el contrato que desplegamos. Si quisiseramos interactuar con m\u00faltiples contratos o usar librer\u00edas adicionales, debemos agregarlas aqu\u00ed. import Web3 from \"web3\"; import metaCoinArtifact from \"../../build/contracts/MetaCoin.json\"; Luego encontramos que se crea el objeto App que contiene el proveedor de Web3, la cuenta que estamos usando, y una referencia al contrato. const App = { web3: null, account: null, meta: null, M\u00e1s abajo encontramos varias funciones as\u00edncronas que nos permiten interactuar con el contrato ( start , refreshBalance , sendCoin ), y una que nos permite cambiar el contenido de la p\u00e1gina ( setStatus ). Si exploramos con detenimiento estas funciones, encontraremos que usan a web3 , account y meta para realizar tareas similares a las que realizabamos desde la consola de Truffle. Finalmente tenemos algo de c\u00f3digo que nos permite obtener el proveedor Web3 de nuestro navegador, es decir, nos permite usar nuestras cuentas que tenemos en Metamask. En espec\u00edfico son las siguientes l\u00edneas las que nos permiten el acceso. App.web3 = new Web3(window.ethereum); window.ethereum.enable(); En el siguiente ejercicio desplegaremos nuestro propio contrato y cambiaremos el contenido de este archivo para poder interactuar con \u00e9l. Generando nuestra aplicaci\u00f3n web \u00b6 Una vez que hayamos probado localmente nuestra aplicaci\u00f3n, podemos generarla para poder desplegarla en cualquier otro servidor. Usamos el siguiente comando para esto. npm run build Esto nos genera una carpeta llamada dist que contiene los archivos index.html e index.js . Si abrimos este index.js notaremos que no es el mismo que nosotros escribimos, sino es el que Webpack gener\u00f3 al empaquetar todas las librer\u00edas juntas. Podemos colocar estos archivos en cualquier servidor (incluso en Github Pages) y con eso podemos acceder a nuestra aplicaci\u00f3n web e interactuar con nuestro contrato.","title":"Utilizando Webpack"},{"location":"exercises/part4/webpack/#utilizando-webpack","text":"Webpack es una herramienta que nos permite tomar m\u00faltiples librer\u00edas y dependencias y empaquetarlas de forma que sea f\u00e1cil incluirlas en una p\u00e1gina web. Webpack es la herramienta recomendada por Truffle para incluir Web3 e interacciones con contratos en nuestros sitios.","title":"Utilizando Webpack"},{"location":"exercises/part4/webpack/#preparando-el-entorno-de-trabajo","text":"Truffle nos provee paquetes ejemplo listos para usarse. Para usar Webpack nos provee un paquete que incluye contratos, migraciones, tests, interfaz de usuario y scripts para generar nuestro sitio. Podemos seguir las instrucciones en el tutorial de Truffle + Webpack , o las instrucciones siguientes. Como ya tenemos Truffle instalado, creamos un directorio nuevo y all\u00ed desempaquetamos el ejemplo de Webpack. mkdir webpack-demo cd webpack-demo truffle unbox webpack Esto descargar\u00e1 el ejemplo y colocar\u00e1 en las carpetas respectivas todos los archivos. Debemos abrir cada uno de los contratos, y al inicio debemos realizar un peque\u00f1o cambio. Reemplazamos <0.7.0 por <=0.8.16 para usar la versi\u00f3n del compilador de Solidity que tenemos instalada. pragma solidity >=0.4.21 <=0.8.16; Para poder continuar, debemos desplegar los contratos que modificamos. Estos contratos representan MetaCoin, el cual es un tokene sencillo. Recordamos que para poder desplegar debemos colocar nuestra llave en el archivo .env as\u00ed como realizar las configuraciones necesarias en truffle-config.js . Tambi\u00e9n si no los instalamos de forma global, instalaremos dotenv y hdwallet-provider en la carpeta actual. npm install dotenv npm install @truffle/hdwallet-provider Despu\u00e9s de esta instalaci\u00f3n podemos desplegar con el siguiente comando. truffle migrate --network goerli","title":"Preparando el entorno de trabajo"},{"location":"exercises/part4/webpack/#ejecutando-la-aplicacion-web","text":"Con nuestro contrato desplegado, vamos a la carpeta app y desde all\u00ed iniciamos un servidor de pruebas. cd app npm run dev Podremos ver algunos mensajes en nuestra terminal que nos indican que un servidor est\u00e1 ejecut\u00e1ndose en http://localhost:8000/ y que Webpack fue el encargado de preparar todas las librer\u00edas necesarias para su funcionamiento. Abrimos esta p\u00e1gina en nuestro navegador y al hacerlo notaremos que se abrir\u00e1 una ventana de Metamask. Tras ingresar a Metamask, se nos preguntar\u00e1 si queremos permitir que el sitio se conecte con nuestra billetera, aceptamos esto haciendo click en Next y luego en Connect . Metamask nos pregunta si deseamos dar acceso a nuestra cuenta Luego de esto la aplicaci\u00f3n ejemplo est\u00e1 lista para usarse, solo debemos recargar la p\u00e1gina. Tras recargar, veremos que tenemos disponible 10000 META , es decir de nuestro token de prueba. Aplicaci\u00f3n web ejecut\u00e1ndose en nuestro navegador Podemos usar esta interfaz para realizar transferencias del token hacia otras direcciones.","title":"Ejecutando la aplicaci\u00f3n web"},{"location":"exercises/part4/webpack/#funcionamiento-de-webpack","text":"Cuando usamos el comando npm run dev se ejecuta webpack-dev-server el cual es el encargado de iniciar un servidor para pruebas. Webpack utiliza el archivo webpack.config.js para saber cu\u00e1l es su punto de inicio, es decir, cu\u00e1l es el script principal de nuestra aplicaci\u00f3n web. Podemos explorar el archivo index.js el cual es el punto de inicio.","title":"Funcionamiento de Webpack"},{"location":"exercises/part4/webpack/#detalles-de-indexjs","text":"Al inicio de este archivo encontramos que se importan dos elementos, la librer\u00eda Web3 y un JSON que representa el contrato que desplegamos. Si quisiseramos interactuar con m\u00faltiples contratos o usar librer\u00edas adicionales, debemos agregarlas aqu\u00ed. import Web3 from \"web3\"; import metaCoinArtifact from \"../../build/contracts/MetaCoin.json\"; Luego encontramos que se crea el objeto App que contiene el proveedor de Web3, la cuenta que estamos usando, y una referencia al contrato. const App = { web3: null, account: null, meta: null, M\u00e1s abajo encontramos varias funciones as\u00edncronas que nos permiten interactuar con el contrato ( start , refreshBalance , sendCoin ), y una que nos permite cambiar el contenido de la p\u00e1gina ( setStatus ). Si exploramos con detenimiento estas funciones, encontraremos que usan a web3 , account y meta para realizar tareas similares a las que realizabamos desde la consola de Truffle. Finalmente tenemos algo de c\u00f3digo que nos permite obtener el proveedor Web3 de nuestro navegador, es decir, nos permite usar nuestras cuentas que tenemos en Metamask. En espec\u00edfico son las siguientes l\u00edneas las que nos permiten el acceso. App.web3 = new Web3(window.ethereum); window.ethereum.enable(); En el siguiente ejercicio desplegaremos nuestro propio contrato y cambiaremos el contenido de este archivo para poder interactuar con \u00e9l.","title":"Detalles de index.js"},{"location":"exercises/part4/webpack/#generando-nuestra-aplicacion-web","text":"Una vez que hayamos probado localmente nuestra aplicaci\u00f3n, podemos generarla para poder desplegarla en cualquier otro servidor. Usamos el siguiente comando para esto. npm run build Esto nos genera una carpeta llamada dist que contiene los archivos index.html e index.js . Si abrimos este index.js notaremos que no es el mismo que nosotros escribimos, sino es el que Webpack gener\u00f3 al empaquetar todas las librer\u00edas juntas. Podemos colocar estos archivos en cualquier servidor (incluso en Github Pages) y con eso podemos acceder a nuestra aplicaci\u00f3n web e interactuar con nuestro contrato.","title":"Generando nuestra aplicaci\u00f3n web"},{"location":"lessons/lesson1/","text":"Entendiendo blockchain y criptomonedas \u00b6","title":"Teor\u00eda"},{"location":"lessons/lesson1/#entendiendo-blockchain-y-criptomonedas","text":"","title":"Entendiendo blockchain y criptomonedas"},{"location":"lessons/lesson2/","text":"Conceptos clave \u00b6","title":"Teor\u00eda"},{"location":"lessons/lesson2/#conceptos-clave","text":"","title":"Conceptos clave"},{"location":"lessons/lesson3/","text":"Aplicaciones de blockchain \u00b6","title":"Teor\u00eda"},{"location":"lessons/lesson3/#aplicaciones-de-blockchain","text":"","title":"Aplicaciones de blockchain"},{"location":"lessons/lesson4/","text":"Contratos inteligentes \u00b6","title":"Teor\u00eda"},{"location":"lessons/lesson4/#contratos-inteligentes","text":"","title":"Contratos inteligentes"}]}